<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Jim Liu's Blog]]></title>
  <subtitle><![CDATA[Again, Jim Liu's Blog]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://jimliu.net//"/>
  <updated>2015-09-30T04:45:18.000Z</updated>
  <id>http://jimliu.net//</id>
  
  <author>
    <name><![CDATA[Jim Liu]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[十一长假之前悄悄发布一个情怀之作-h5pal（无底天坑）]]></title>
    <link href="http://jimliu.net/2015/09/30/h5pal-release/"/>
    <id>http://jimliu.net/2015/09/30/h5pal-release/</id>
    <published>2015-09-30T15:33:33.000Z</published>
    <updated>2015-09-30T04:45:18.000Z</updated>
    <content type="html"><![CDATA[<p>趁着大家都赶着休假去了，悄悄发布，免得被喷，23333。</p>
<p><a href="https://github.com/LiuJi-Jim/h5pal" target="_blank" rel="external">h5pal</a>是《仙剑奇侠传》的web移植。</p>
<a id="more"></a>
<h2 id="0-_前言">0. 前言</h2><p>这是一个坑了太久太久的项目，久到我已经不记得挖这个坑是什么时候了。大概是13年的夏天吧，我挖了这个坑，然后信心满满的在当年十一长假宅了N天（我还比较清楚的记得那时候正是WOW开荒围攻奥格瑞玛副本的阶段），写下了整个框架，以及最核心的一部分代码，然后，就没有然后了。</p>
<p>大概一年后，我又翻出来了这个坑，重构了大量的代码，但是进度几乎没有实质性的进步，甚至因为重构而有所倒退- -“，不过因为读了《游戏引擎架构》这本书，我对这个坑又有了新的认识，对于这个程序到底要怎么写心里有谱多了。</p>
<p>本来计划是在今年夏天搞出来，这样可以赶上仙剑20周年（1995年7月）发布，不过不用想也知道毫无疑问是继续坑了。</p>
<p>磕磕绊绊到如今，总算是把游戏的总体完成度拉到了一个比较能见人的程度，于是我觉得还是赶紧发布的好，免得又变有生之年了。</p>
<h2 id="1-_无图言屌">1. 无图言屌</h2><p><strong><a href="http://v.youku.com/v_show/id_XMTM0ODQzNzM2NA==.html" target="_blank" rel="external">优酷视频</a></strong>——有视频有JB！</p>
<p><img src="http://liuji-jim.github.io/h5pal/screenshots/00.png" alt=""></p>
<p><img src="http://liuji-jim.github.io/h5pal/screenshots/01.png" alt=""></p>
<p><img src="http://liuji-jim.github.io/h5pal/screenshots/02.png" alt=""></p>
<p><img src="http://liuji-jim.github.io/h5pal/screenshots/03.png" alt=""></p>
<p><img src="http://liuji-jim.github.io/h5pal/screenshots/04.png" alt=""></p>
<p><img src="http://liuji-jim.github.io/h5pal/screenshots/05.png" alt=""></p>
<p><img src="http://liuji-jim.github.io/h5pal/screenshots/06.png" alt=""></p>
<p><img src="http://liuji-jim.github.io/h5pal/screenshots/07.png" alt=""></p>
<p><img src="http://liuji-jim.github.io/h5pal/screenshots/dpg.gif" alt=""></p>
<h2 id="2-_自问自答的FAQ">2. 自问自答的FAQ</h2><h3 id="2-1-_能玩吗？">2.1. 能玩吗？</h3><p><strong>能</strong>。但在GitHub repo里并不会包含游戏的资源文件，于是需要自己去找（嘿嘿<a href="http://pan.baidu.com/s/1dD2kHLv" target="_blank" rel="external"><del>mq2x</del></a>）。由于不分发游戏资源文件，且考虑到体积，我也不会提供一个在线游玩的版本。所以基本上只有开发者或者动手能力强的同学才能玩上它了（如果你真的想玩……）</p>
<p>不考虑遇到BUG（无数个）造成游戏直接罢工的情况下（当然身为作者的我是可以驾轻就熟地避过这些BUG的233333），<strong>已经可以从新开游戏一直玩到大结局了，而且我已经通关两三遍了XD</strong></p>
<h3 id="2-2-_这是什么程度的移植？">2.2. 这是什么程度的移植？</h3><p><strong>完整移植</strong>。h5pal从<a href="http://sdlpal.codeplex.com/" target="_blank" rel="external">SDLPAL</a>里平移（就是抄啦）了大量的代码。SDLPAL是一个基于SDL的跨平台版仙剑，它已经能顺利的运行在Windows、Linux、OS X、Symbian、PSP、Android等很多种平台上面。</p>
<p>h5pal与SDLPAL有着相同的出发点，就是实现仙剑的主程序，你只需要有仙剑的资源文件就可以运行整个游戏。</p>
<h3 id="2-3-_为什么需要仙剑的原版资源文件">2.3. 为什么需要仙剑的原版资源文件</h3><p>出于上面所说的只实现主程序的出发点，并且出于技(xīn)术(lǐ)洁(biàn)癖(tài)，我选择不对资源文件进行任何预处理。如果按照现代游戏引擎的方式，先把资源文件里的位图、Sprite、数据等资料都解开成更适合HTML5/JS所需要的结构化数据，整个开发也许会变得容易很多。</p>
<p><strong>但那样就不好玩了</strong></p>
<p><img src="/uploads/2015/not-beautiful.jpg" alt=""></p>
<p>因此最终我选择了保留SDLPAL的味道，不对资源文件进行任何的预处理，而是直接读取原始资源文件。当然因为完成度和工作量的原因我只能支持一个固定版本的资源文件，而SDLPAL则有更强的兼容性（甚至支持民间MOD仙剑梦幻版）。并且SDLPAL实现了半即时制战斗的创新，我个人不太喜欢，也没有迁移这个。</p>
<h3 id="2-4-_使用了什么游戏引擎/框架/库/技术">2.4. 使用了什么游戏引擎/框架/库/技术</h3><p>从思路上看的话，可以说使用了<a href="https://github.com/finscn/The-Best-JS-Game-Framework" target="_blank" rel="external">The-Best-JS-Game-Framework</a>。</p>
<p>最主要的，这个程序主要使用了<a href="https://github.com/tj/co" target="_blank" rel="external">co</a>，使用co/yield/generator来改善异步开发的体验，让整个庞大的程序实现成为了可能——前言中说的去年的一次大重构就是干这个——这是一个非常重要的重构，过去的话一个异步的update/render loop就可以让人抓狂，以至于我现在根本不想再写异步的JS了T_T，也许有机会我会再写一篇文章来介绍JS“同步”编程以及<a href="https://github.com/ubolonton/js-csp" target="_blank" rel="external">js-csp</a>这个非常好玩的东西。但你知道co其实是一个非常非常简单的库，所以即使没有co的话，<a href="http://jimliu.net/2014/11/28/a-brief-look-at-es6-generator-function/">自己造一个</a>堪堪一用的轮子也非常容易，所以想解除这个依赖是很简单的。</p>
<p>在这个坑之初，原生Promise还没普及，所以引入了<a href="https://github.com/kriskowal/q" target="_blank" rel="external">q</a>，但其实在整个项目中贯彻了co之后，很少用得着Promise，并且也可以很容易的向原生Promise迁移，当然因为懒我是没这么干的。</p>
<p>其他方面可以说几乎没有依赖第三方的库了，可能还有jQuery啊这类的东西，只是用了一丁丁点，非常容易解除依赖。</p>
<p><strong>仙剑是一个很古老的游戏，使用现代游戏引擎重新实现仙剑的主程序并没有太直接的帮助</strong>。现代的2D游戏引擎围绕Sprite和场景管理为主，虽然在SDLPAL和h5pal中也有Sprite和场景模块，但具体到技术层面和现代游戏引擎里的还是差别比较大。再加上技(xīn)术(lǐ)洁(biàn)癖(tài)的原因，我没有用任何现代的游戏引擎，不过等到轮子造得差不多的时候，发现游戏引擎的思想果然是几十年没有太大变化……</p>
<p>由于音乐和音效系统彻底坑了（原因见后文），所以WebAudio暂时不涉及。图形方面只涉及到canvas 2D，并且因为仙剑本身的资源都是像素级的，所以图形这一层也基本上都是在<code>getImageData/putImageData</code>的层次直接操作像素，并没有使用任何canvas的绘图API。因此如果后续把绘图层迁移到WebGL也会很简单，不过目前看来完全没有这个必要。</p>
<p>h5pal使用GPLv3发布，我对开源协议几乎不懂，只知道GPL是比较严格的一种协议，而且SDLPAL是用GPLv3的，考虑到我抄了他很多代码，于是用了这个至少不比他宽松的协议，并且再次向SDLPAL表示敬意。</p>
<h3 id="2-5-_为什么没实现音乐/音效部分，不是有Audio和WebAudio了吗？">2.5. 为什么没实现音乐/音效部分，不是有Audio和WebAudio了吗？</h3><p>音效部分仙剑用的是voc格式，这个格式太古老了以至于Audio和WebAudio都不可能直接支持它。为了不对资源文件做预处理的原则，在这里就让它坑了。</p>
<p>音乐部分仙剑用的是MIDI，目前在Web里有<a href="https://github.com/mudcube/MIDI.js" target="_blank" rel="external">MIDI.js</a>可以处理（P.S.这个项目相当之屌！）。但是懂MIDI的人都知道，MIDI格式本身并不复杂，难的在于实现音色库。这样一来会引入很大一堆东西，甚至上百MB的音色库，这非常不现实，所以我选择先(forever)把它坑了。</p>
<h3 id="2-6-_为什么没有实现存档？">2.6. 为什么没有实现存档？</h3><p>其实是实现了（隐藏功能哦），但因为存档到资源文件的话，需要向服务端POST，这样需要CGI支持了，麻烦……然后我为了方便自己玩就用了很猥琐的办法实现（其实还是堪堪一用的）。</p>
<h3 id="2-7-_现在看起来都是dev状态，什么时候会成为成品游戏？">2.7. 现在看起来都是dev状态，什么时候会成为成品游戏？</h3><p>也许永远不会，因为没动力再把各种BUG还有音频部分的坑填了……</p>
<p>如果有生之年真的能填，那么也许可以用node-webkit这类的东西打包成成品游戏，不过……有意思么……</p>
<h3 id="2-8-_有可能在手机上运行吗">2.8. 有可能在手机上运行吗</h3><p>目前不可以，性能最好的iOS Safari尚未支持yield/generator，而Android Chrome我目前没有关注。</p>
<p>性能方面没有明确的评价，在MacbookPro上CPU占用率并不高，但是内存很高（因为惨无人道的用内存，毫无优化之心），所以我觉得还是挺堪忧的。</p>
<h3 id="2-9-_所以总的完成度？">2.9. 所以总的完成度？</h3><p>直接搬GitHub上给（胡邹）的吧：</p>
<table>
<thead>
<tr>
<th>模块</th>
<th style="text-align:right">进度</th>
</tr>
</thead>
<tbody>
<tr>
<td>资源</td>
<td style="text-align:right">90%</td>
</tr>
<tr>
<td>读档</td>
<td style="text-align:right">99%</td>
</tr>
<tr>
<td>存档</td>
<td style="text-align:right">40%</td>
</tr>
<tr>
<td>Surface</td>
<td style="text-align:right">90%</td>
</tr>
<tr>
<td>位图</td>
<td style="text-align:right">99%</td>
</tr>
<tr>
<td>Sprite</td>
<td style="text-align:right">99%</td>
</tr>
<tr>
<td>地图</td>
<td style="text-align:right">90%</td>
</tr>
<tr>
<td>场景</td>
<td style="text-align:right">90%</td>
</tr>
<tr>
<td>调色盘</td>
<td style="text-align:right">90%</td>
</tr>
<tr>
<td>文本</td>
<td style="text-align:right">99%</td>
</tr>
<tr>
<td>脚本（天坑）</td>
<td style="text-align:right">70%</td>
</tr>
<tr>
<td>平常UI</td>
<td style="text-align:right">90%</td>
</tr>
<tr>
<td>战斗UI</td>
<td style="text-align:right">90%</td>
</tr>
<tr>
<td>战斗（天坑）</td>
<td style="text-align:right">70%</td>
</tr>
<tr>
<td>播片</td>
<td style="text-align:right">90%</td>
</tr>
<tr>
<td>结局</td>
<td style="text-align:right">95%</td>
</tr>
<tr>
<td>音乐</td>
<td style="text-align:right">0%</td>
</tr>
<tr>
<td>音效</td>
<td style="text-align:right">0%</td>
</tr>
</tbody>
</table>
<h2 id="3-_后记">3. 后记</h2><p>（呃，这个真的是流水账了，可能就长了）</p>
<p>其实一开始让我发布h5pal的时候，我是拒绝的。因为我只想把它当做一个情怀的玩具，烂在自己的硬盘里面算了。而且心理洁癖造成我觉得没完成的东西就不要发布了吧。后来在@licstar的鞭策之下一点点推进，断断续续改了很多没头绪的BUG。突然有一天似乎流程能走通了（那时候还没实现战斗），而他竟然磕磕绊绊的就玩到通关了，我特么真是惊了，瞬间有种拨云见日的感觉。</p>
<p>我知道即使发布了也估计没有人会用这个版本来玩，不过如标题所说，情怀之作。今年的仙剑6让很多玩家非常失望，而身为老仙剑迷的我其实从4代过后就已经弃坑了。尽管如此，我一直都认为如果想做一名合格的RPG玩家，从游戏评论的角度出发的话，仙剑1一定是必玩之作，因为在那个时候它是中文RPG游戏当中能和同期日系RPG有一战的一作，代表了当年RPG的最高水平，可以称为游戏发展史上的一个标志。选择仙剑很大一部分原因当然是有SDLPAL这个现成的对象可以抄，不过情怀满分这一点也是其他游戏不可取代的。</p>
<p>我是一名游戏爱好者，也一直想着能做游戏，并且是想做出版级的“大”游戏。不过因为各种原因，似乎离这个目标越来越远了。其实游戏是一个非常大也非常复杂的软件工程，甚至有人说游戏是软件工程当中最难的一个分支。我一直非常佩服各种3A大厂，能够集结上千人，几千万美元的资金做出一部部牛逼的作品（每打通一个游戏我都要把制作群字幕看完），也非常佩服各路独立游戏神人，能在那么有限的资源下做出精彩的作品。虽然仙剑不是新IP，我想我也不太有可能做新IP，甚至说没有SDLPAL和PalResearch的基础的话也不可能做出h5pal，不过这也已经在很大程度上满足了我做游戏的梦想吧，能做到现在这个程度我还是很开心的。</p>
<p>至于为什么是用HTML5/JS来实现呢？首先我本职是做前端的，对JS是非常熟悉，也可以当练手用呗（虽然整个h5pal的JS代码几乎没有任何技术难度可言吧……）其次就是因为SDLPAL本身已经做到跨很多很多平台了，惟独web这个炙手可热的平台还是个空缺。我在网上也没有找到仙剑1的完整web移植。另一方面，因为有别的一些老游戏的web移植中有很多（比如Diablo、星际）只是伪移植，也就是用原版游戏资源解包以后在web上做一个demo，根本没法玩的，这一点坚定了我做完整移植和资源文件不进行预处理的目标。</p>
<p>最大的遗憾也是留下了音频这个无底天坑，因为仙剑1的经典的配乐很得人心，没有音乐的伴随，即使体验剧情也会觉得少了太多味道，可惜可惜。</p>
<p>h5pal里面实现了一个用来读取C结构体指针的库，C里面通过指针转换，从文件里读取一段字节直接“铺开内存”就能转成一个结构体，这一点非常好用。这个JS库能把ArrayBuffer直接转成JS对象，利用getter/setter可以把对字段的操作落在ArrayBuffer（JS里的字节数组）上，这样一来还可以让不同对象共享内存（比如实现一个union什么的），在h5pal里是一个很核心的库了（重构的时候也是血虐啊）。我觉得还挺方便的，也许用在node里的话实现一些native互访以及网络协议的时候会用得着吧。以后有时间的话可能会考虑把它重构一下，API弄弄更易用了单独发布一个库吧（有生之年</p>
<p>最后感谢@licstar的鞭策（催）和积极的帮忙测试，如果不是这么催的话估计早就烂硬盘里了。</p>
<p>最后的最后，我才发现仙剑里的女生都很积极主动啊，有的地方甚至还挺毁三观的……</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>趁着大家都赶着休假去了，悄悄发布，免得被喷，23333。</p>
<p><a href="https://github.com/LiuJi-Jim/h5pal">h5pal</a>是《仙剑奇侠传》的web移植。</p>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JS中的二进制操作简介]]></title>
    <link href="http://jimliu.net/2015/09/26/a-brief-look-at-binary-ops-in-js/"/>
    <id>http://jimliu.net/2015/09/26/a-brief-look-at-binary-ops-in-js/</id>
    <published>2015-09-26T04:31:35.000Z</published>
    <updated>2015-09-26T05:55:43.000Z</updated>
    <content type="html"><![CDATA[<p>写这篇博客的起源是在<a href="http://div.io" target="_blank" rel="external">div.io</a>上的一篇<a href="http://div.io/topic/766" target="_blank" rel="external">文章《你所不知道的JavaScript数组》by 小胡子哥</a>下的评论中的讨论。</p>
<p>因为随着XHR2和现代浏览器的普及，在浏览器当中处理二进制不再向过去那样无所适从，随着Canvas/WebGL等新技术逐渐开始进入大众视野，也会用到一些字节数组或者16位、8位整数等东西。在node.js刚刚发布的4.0版本中，Buffer的底层使用了更符合JS标准的<code>Uint8Array</code>来实现，浏览器和node.js再次向相同的目标靠近了一点点，所以对于JS中处理二进制，我就打算写这篇文章作一个入门性质的流水账，方便一些对二进制处理不了解的同学快速入门，虽然在前端领域用到的不多，不过也可以作为茶余饭后的休闲谈资。</p>
<a id="more"></a>
<h2 id="二进制数据在JS程序里的表达">二进制数据在JS程序里的表达</h2><p>现今世界上几乎所有的计算机体系结构都是以字节（byte）为二进制数据的基本单位（注：不是说最小单位），所以二进制常常以字节数组的形式存在于程序当中。例如在C#里面，就用<code>byte[]</code>，标准C里面没有<code>byte</code>类型，但可以通过<code>typedef</code>把<code>byte</code>定义为<code>unsigned char</code>的别名，效果是一样的。</p>
<p>JS设计之初似乎根本没想过要处理二进制的东西，加上对类型的极度弱化，对于字节的概念可以说是非常非常的模糊。如果要表达字节数组，那么似乎只能用一个普通数组来表示。</p>
<p>HTML5体系引入了一大堆新的东西，比如XHR2，是可以上传或下载二进制内容的，与之配套的东西就是JS里的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="external">ArrayBuffer</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="external">Typed Array</a>了。</p>
<p><code>ArrayBuffer</code>是一个固定长度的字节序列，你可以通过<code>new ArrayBuffer(length)</code>来得到一片空间，或者用下文将会介绍的方法从XHR2等途径获取。由于内部实现与数组不一样，<code>ArrayBuffer</code>通常都是连续内存（注意，这只是经验之谈，并不是规范也不是文档所明确的），因此对于高密度的访问操作而言它比JS中的Array速度会快很多（但并不要用它来简单地代替Array）。如果用Chrome的Profile工具查看Heap Snapshot，会发现ArrayBuffer会被单独列为一类，也许它的内存分配和布局与Array以及其他JS对象有一些差别吧。</p>
<p><code>ArrayBuffer</code>是不能直接被访问的，因此需要借助Typed Array。Typed Array是一组具体数据类型的Array-Like类型的统称，包括</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Int8Array</span>             <span class="number">8</span>位有符号整数，类似于C里面的char</span><br><span class="line"><span class="built_in">Uint8Array</span>            <span class="number">8</span>位无符号整数，类似于C里面的unsigned char</span><br><span class="line"><span class="built_in">Uint8ClampedArray</span>     <span class="number">8</span>位无符号整数，跟Uint8类似，但在溢出处理上不大一样</span><br><span class="line"><span class="built_in">Int16Array</span>            后面这些类型就不罗嗦了</span><br><span class="line"><span class="built_in">Uint16Array</span></span><br><span class="line"><span class="built_in">Int32Array</span></span><br><span class="line"><span class="built_in">Uint32Array</span></span><br><span class="line"><span class="built_in">Float32Array</span></span><br><span class="line"><span class="built_in">Float64Array</span></span><br></pre></td></tr></table></figure>
<p>Typed Array的背后是一个<code>ArrayBuffer</code>，也就是说，<strong>事实上的数据是存在<code>ArrayBuffer</code>里面的，而Typed Array只是给你提供了一个某种类型的读写接口</strong>，用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays" target="_blank" rel="external">MDN的话</a>说，叫做</p>
<blockquote>
<p>Multiple views on the same data</p>
</blockquote>
<p>举个栗子，如果我们有一个<code>ArrayBuffer</code>名为buffer（先不考虑怎么构造这个测试数据），内容如下：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01 02 03 04</span> <span class="number">05 06 07 08</span></span><br></pre></td></tr></table></figure>
<p>也就是说它有8个字节，我们分别用它来构造<code>Uint8Array</code>, <code>Uint16Array</code>, <code>Uint32Array</code>，则可以得到</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  u8 = <span class="keyword">new</span>  <span class="built_in">Uint8Array</span>(buffer); <span class="comment">// length为8</span></span><br><span class="line"><span class="keyword">var</span> u16 = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(buffer); <span class="comment">// length为4</span></span><br><span class="line"><span class="keyword">var</span> u32 = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(buffer); <span class="comment">// length为2</span></span><br></pre></td></tr></table></figure>
<p>它们的内容分别为</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">513</span>, <span class="number">1027</span>, <span class="number">1541</span>, <span class="number">2055</span>]</span><br><span class="line">[<span class="number">67305985</span>, <span class="number">134678021</span>]</span><br></pre></td></tr></table></figure>
<p>这不难理解。</p>
<p>可以看出，如果要手工构造上面的测试数据<code>ArrayBuffer</code>，用<code>Uint8Array</code>就会很方便（呃事实上这是我个人最常用的一种Typed Array）。</p>
<p>而如果用同样的<code>ArrayBuffer</code>构建带符号整数类型，则可能因为整数溢出而得到不同的结果，上面的例子并没有碰到，有兴趣的话可以自己试试。因此使用Typed Array也可以用来做有符号数和无符号数的转换。</p>
<p>如果你用过canvas的<code>getImageData/putImageData</code>的话，会发现它给你的就是一个<code>Uint8ClampedArray</code>，这东西访问起来速度比JS的原生Array快很多，使得对canvas进行高速的像素操作成为可能。</p>
<p>然而最最重要的一个概念还是：<strong>Typed Array不直接存放任何数据，所有对Typed Array进行读写的操作，最终都会落实到它背后所持有的<code>ArrayBuffer</code>的身上。</strong><code>ArrayBuffer</code>才是真正的<strong>raw bytes，而Typed Array只是一个操作窗口/操作视图（View）。</strong></p>
<h2 id="获取二进制数据">获取二进制数据</h2><p>nodejs那边先按住不表，这里谈谈在网页里如何获取二进制数据？常见的办法有3种，1是通过<code>XMLHttpRequest 2</code>，2是通过<code>File</code>和<code>Blob</code>一套相关接口。</p>
<h3 id="通过XMLHttpRequest_2">通过XMLHttpRequest 2</h3><p>XHR2的接口跟XHR几乎是一样的，当制定<code>xhr.responseType = &#39;arraybuffer&#39;</code>以后，在成功获取数据的回调里就可以通过<code>xhr.response</code>来得到请求结果的<code>ArrayBuffer</code>了，然后就可以按照你的意愿来构造各种Typed Array进行访问。</p>
<p><code>responseType</code>还可以有<code>blob</code>取值，可以用<code>xhr.response</code>获得<a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="external">Blob</a>对象。</p>
<h3 id="通过File和Blob">通过File和Blob</h3><p>在HTML5中提供了对表单的文件控件<code>&lt;input type=&quot;file&quot; /&gt;</code>更丰富的操作，可以通过<code>input</code>DOM对象的<code>.files</code>来获取一个<code>FileList</code>，当然通常浏览器都只提供了单选的文件控件，于是这里都只会有一个<a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank" rel="external">File</a>对象。另外，通过拖拽、剪贴板等方式也能获取到<code>File</code>或者<code>Blob</code>。</p>
<p><code>File</code>继承了<code>Blob</code>，并提供了<code>name</code>, <code>lastModifiedDate</code>等基础元数据，但是依然是一个深度封装，不能直接获取到它的二进制。</p>
<p><code>Blob</code>是<code>Binary large object</code>的缩写，它与<code>ArrayBuffer</code>的区别是除了raw bytes以外它还提供了mime type作为元数据。但它依然是无法直接被读写的。</p>
<p>这时候需要借助<a href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader" target="_blank" rel="external">FileReader</a>的帮忙。<code>FileReader</code>提供了一组用来将<code>Blob</code>读取为更为实用的类型的方法</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">readAsArrayBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">readAsBinaryString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">readAsDataURL</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">readAsText</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>例如<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = get_file_some_how();</span><br><span class="line"><span class="keyword">var</span> fr = new <span class="type">FileReader</span>();</span><br><span class="line">fr.onload = function(e) &#123;</span><br><span class="line">    e.target.<span class="literal">result</span>; // 读取的结果</span><br><span class="line">&#125;;</span><br><span class="line">fr.readAsDataUrl(file); // readAsArrayBuffer</span><br></pre></td></tr></table></figure></p>
<p>可以干什么呢？例如图片上传之前的本地预览（甚至基于canvas的编辑）等等都可以实现了。</p>
<p><code>Blob</code>的其他构造方法多而杂，这里就先不到处搬运文档了。</p>
<h2 id="消费二进制数据">消费二进制数据</h2><p>何谓消费？最常见的方式也许就是通过XHR2直接把二进制数据以文件方式POST到服务端去。</p>
<p>这里我比较推荐使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" target="_blank" rel="external">FormData</a>来构造POST数据。因为在服务端收的时候会比较容易一些，具体有兴趣可以去找找别人的例子。</p>
<p>虽然直接提交<code>ArrayBuffer</code>也是可以的，但是这种时候服务端收到的POST body会是一大团，用起来不方便。如果要使用<code>FormData</code>来提交<code>ArrayBuffer</code>，需要先将其构造成<code>Blob</code>。</p>
<h2 id="对Typed_Array的构造留个心眼">对Typed Array的构造留个心眼</h2><p>当使用<code>new xxxxxArray(arrayBuffer)</code>这个重载进行构造的时候，它会默认基于此<code>ArrayBuffer</code>进行构造。但当使用<code>new xxxxArray(another_typed_array)</code>这个重载的时候，则是进行“拷贝构造”，这样两个Typed Array会指向不同的buffer，需要注意这是否符合预期。</p>
<p>如果需要基于同一个<code>ArrayBuffer</code>来构造Typed Array，可以使用Typed Array的<code>buffer</code>, <code>byteLength</code>, <code>byteOffset</code>来获取它背后的<code>ArrayBuffer</code>。</p>
<h2 id="Tips（坑）">Tips（坑）</h2><h3 id="对内存对齐留个心眼">对内存对齐留个心眼</h3><p>当使用ArrayBuffer来构造Typed Array的时候，可以指定<code>byteOffset</code>参数，例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = get_array_buffer_some_how();</span><br><span class="line"><span class="keyword">var</span> i16 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码就能以<code>buffer</code>向后偏移10字节处为起点来构造<code>Int16Array</code>，但是如果将10设置为一个奇数，会发现如下错误：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RangeError: <span class="built_in">start</span> <span class="built_in">offset</span> <span class="operator">of</span> Int16Array should be <span class="operator">a</span> multiple <span class="operator">of</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这是因为Typed Array对内存对齐有要求，它不能在非对齐的位置建立，同理，<code>Uint32Array</code>和<code>Int32Array</code>则要求偏移量是4字节对齐的。</p>
<p>因此如果你希望在非对齐的位置进行读写，则需要借助<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="external">DataView</a>的帮忙。</p>
<h3 id="对字节序留个心眼">对字节序留个心眼</h3><p><strong>我们日常中所写的程序，几乎都不需要关心<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F" target="_blank" rel="external">字节序</a></strong>，因此这个问题没那么严重，知道自己的程序会有字节序问题的人，开发到这里也肯定会知道问题的存在，但这里还是稍微提一下。</p>
<p>按照MDN的说法，Typed Array只会使用当前平台的字节序，例如我们现在用的桌面电脑不论PC还是Mac都是x86/x64的，也就是little-endian了。</p>
<p>使用<code>DataView</code>，不仅可以解决上面说到的内存对齐的问题，还可以指定读写时的字节序，具体参数都在文档里面了，就不搬运了。</p>
<p>使用<code>DataView</code>配合Typed Array也可以做到一个检测当前平台字节序的技巧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isLittleEndian</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line">    view.setInt16(<span class="number">0</span>, <span class="number">256</span>, <span class="literal">true</span>); <span class="comment">// 显式以little endian写入数据</span></span><br><span class="line">    <span class="comment">// 此时buf里的内存布局应该是 00 01</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i16 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buf);</span><br><span class="line">    <span class="comment">// 如果以little endian读取，它就是256；以big endian读取，则是1</span></span><br><span class="line">    <span class="keyword">return</span> (i16[<span class="number">0</span>] === <span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你编写的程序需要垮体系结构例如x86/ARM/PPC等，则在交换文件和网络包的时候需要谨慎处理字节序，当然一个办法是在这些地方预先规范统一字节序以防后患。不过那些都是题外话了。</p>
<h3 id="小姐小结"><del>小姐</del>小结</h3><p>使用<code>ArrayBuffer</code>来存储一段字节，使用Typed Array来构建一个具体数值类型的访问窗口，使用<code>DataView</code>对非对齐或在乎字节序的<code>ArrayBuffer</code>进行更精确的操作，使用XHR2, <code>Blob</code>, <code>File</code>, <code>FileReader</code>, <code>FormData</code>等多种方式来获取或消费<code>ArrayBuffer</code>。</p>
<p>另外罗嗦一句，浏览器还提供了一系列所谓的“Binary String”，就是一些看起来像乱码一样的字符串，然后又提供了<code>atob</code>/<code>btoa</code>这种方式来对Base64和“Binary String”进行相互转换，甚至<code>FileReader</code>还提供了<code>readAsBinaryString</code>方法（已经废弃了，善哉）。<strong>这个Binary String真是谁用谁遭殃</strong>，别问我为什么知道……</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>写这篇博客的起源是在<a href="http://div.io">div.io</a>上的一篇<a href="http://div.io/topic/766">文章《你所不知道的JavaScript数组》by 小胡子哥</a>下的评论中的讨论。</p>
<p>因为随着XHR2和现代浏览器的普及，在浏览器当中处理二进制不再向过去那样无所适从，随着Canvas/WebGL等新技术逐渐开始进入大众视野，也会用到一些字节数组或者16位、8位整数等东西。在node.js刚刚发布的4.0版本中，Buffer的底层使用了更符合JS标准的<code>Uint8Array</code>来实现，浏览器和node.js再次向相同的目标靠近了一点点，所以对于JS中处理二进制，我就打算写这篇文章作一个入门性质的流水账，方便一些对二进制处理不了解的同学快速入门，虽然在前端领域用到的不多，不过也可以作为茶余饭后的休闲谈资。</p>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[来吧，造个模板引擎轮子——实现功能]]></title>
    <link href="http://jimliu.net/2015/08/02/make-a-js-tpl-engine--features/"/>
    <id>http://jimliu.net/2015/08/02/make-a-js-tpl-engine--features/</id>
    <published>2015-08-02T12:13:23.000Z</published>
    <updated>2015-08-03T02:27:22.000Z</updated>
    <content type="html"><![CDATA[<p>接<a href="/2015/07/27/make-a-js-tpl-engine--code-gen/">上篇</a>、<a href="/2015/07/22/make-a-js-tpl-engine--parsing/">上上篇</a>和<a href="/2015/07/13/make-a-js-tpl-engine/">上上上篇</a>，这一篇将介绍一些模板语言的<strong>feature</strong>怎么实现，不会都说，会介绍一些比较重要的，思路优先，代码不多。</p>
<a id="more"></a>
<h2 id="函数">函数</h2><p>函数是现代编程语言当中最最最基本的一种代码组织和复用方式了，可以说模板语言作为一种“语言”，这个功能也是必不可少的。上篇文章留了个尾巴，这篇自然从函数开始。</p>
<h3 id="函数定义">函数定义</h3><p>首先确定一下语法，这一篇文章中用我的轮子<a href="https://github.com/liuji-jim/raze-tpl" target="_blank" rel="external">raze-tpl</a>的语法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@func userInfo(user) &#123;</span><br><span class="line">  <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"user"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"name"</span>&gt;</span>@(user.name)<span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"email"</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"mailto:@(email)"</span>&gt;</span>@(user.email)<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前作当中已经能够识别这整个语法结构</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数定义 函数名<span class="comment">(参数列表)</span> &#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对它生成代码其实就不难了，而且因为JS里函数套函数的特性，我们生成的代码天然就可以访问闭包变量，这样的特性和JS非常相似，上手难度位0.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">___custom_func_</span>函数名(<span class="params">参数列表</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __result_asdfghjkl = <span class="string">''</span>;</span><br><span class="line">  函数体</span><br><span class="line">  <span class="keyword">return</span> __result_asdfghjkl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，函数体并不能直接像生成<code>if</code>/<code>foreach</code>那种方式，将结果拼接到整个<code>render</code>函数的结果上，而是需要自己独立维护一个新的结果，并将其返回。</p>
<p>值得注意的是，我们依然需要对函数体内的表达式进行变量名解析，例如上面的例子会解析出<code>user</code>, <code>name</code>, <code>email</code>三个变量名。其中，<strong><code>user</code>是参数列表中已经包含</strong>，所以要将其“白名单”，不然再定义一次，参数很容易瞎。而如果这里出现对闭包变量的使用，也会被解析到变量名，如果在函数体内生成<code>var</code>变量声明语句，就违背了我们想要实现对闭包变量访问的初衷。所以一个比较无脑的办法就是，把函数内的变量名声明也提高到<code>render</code>函数的级别。例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">___render</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> userList = data[<span class="string">'userList'</span>]; <span class="comment">// 这个是函数调用的参数表达式解析出来的变量名</span></span><br><span class="line">  <span class="keyword">var</span> name = data[<span class="string">'name'</span>]; <span class="comment">// 这个是无用功</span></span><br><span class="line">  <span class="keyword">var</span> email = data[<span class="string">'email'</span>]; <span class="comment">// 这个也是无用功</span></span><br><span class="line">  <span class="keyword">var</span> closure_variable = data[<span class="string">'closure_variable'</span>]; <span class="comment">// 这个是将下文的闭包变量提前声明的结果</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">___custom_func_userInfo</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里面就可以正常访问 clousure_variable这个闭包变量了</span></span><br><span class="line">    <span class="comment">// 同时，函数内访问“全局”变量（也就是data参数的字段</span></span><br><span class="line">    <span class="comment">//   也可以被提前到 render 函数的级别，正常访问到</span></span><br><span class="line">    <span class="comment">//   因为它会被当成闭包里的变量</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数调用">函数调用</h3><p>相比之下这个就比函数声明要简单多了，函数调用在<strong>raze-tpl</strong>里的语法是</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;ul class="user-list"&gt;</span></span><br><span class="line">@foreach(i:<span class="keyword">user</span> <span class="keyword">in</span> <span class="keyword">user</span>List) &#123;</span><br><span class="line">  @use <span class="keyword">user</span>Info(<span class="keyword">user</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">&lt;/ul&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的<code>@use</code>代码被解析为</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数调用 函数名<span class="comment">(参数列表)</span></span><br></pre></td></tr></table></figure>
<p>生成的代码就是</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__result += ___custom_func_userInfo<span class="list">(<span class="keyword">user</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>你可以看到其实参数列表是不用动的，当然对它进行变量名分析的过程也还是需要。</p>
<h2 id="block/override">block/override</h2><p>本质上说，<code>block</code>其实也是一个函数定义，只不过它在定义的时候就已经确定了调用位置。例如</p>
<p>定义：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">block</span> pageBody &#123;</span><br><span class="line">  <span class="variable">&lt;span&gt;</span>这个<span class="built_in">block</span>默认只有这么一个空的span<span class="variable">&lt;/span&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>覆盖</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">@override (pageBody) &#123;</span></span><br><span class="line">  <span class="variable">&lt;strong&gt;</span>这里重写了pageBody这个block的定义，将其改为了一个strong<span class="variable">&lt;/strong&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>聪明的你一定早就找到了答案，首先我们可以使用正常的函数定义的方法来将<code>@block</code>定义为一个函数，并且原地生成一条函数调用语句。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function ___custom_block_pageBody() &#123;</span><br><span class="line">  内容</span><br><span class="line">&#125;</span><br><span class="line">__$<span class="literal">result</span> += ___custom_block_pageBody();</span><br></pre></td></tr></table></figure>
<p>然后对于<code>@override</code>，我们照样生成一个函数定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">___custom_block_pageBody</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  新的内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这俩都是“函数声明”，利用JS的语言特性，“声明”会被提前（而函数表达式则不会），那么两个同名函数的声明都会被提前到它们被调用之前；又因为后定义压过先定义，结果后来通过<code>@override</code>重新声明的函数会成为最后的输出——这是一种比较讨巧的做法。</p>
<h2 id="模板继承">模板继承</h2><p>Smarty 3里面加入了模板继承功能，好顶赞，例如首先定义一个<code>layout.html</code>，在里面把框架搭好，埋几个需要被覆写的地方为几个<code>block</code>，然后在<code>xxx-page.html</code>里面，<code>extend layout.html</code>，再按需覆写其中某些<code>block</code>。</p>
<p>利用JS灵活的动态特性，实现这个是比较容易的。</p>
<p>首先当我们解析到<code>@extend</code>的时候，就要改变策略，当前模板的解析结果不要作为<code>render</code>函数返回了，而是将<code>@extend</code>的父模板作为<code>render</code>函数，但当前模板也依然需要进行解析，因为当中的<code>@override</code>是要作用到<code>layout.html</code>里所定义的那些<code>@block</code>身上的。</p>
<p>说起来似乎很麻烦，不过如果你真的在动手造轮子，聪明的你一定会有办法的。</p>
<h2 id="filter">filter</h2><p>大多数模板引擎对于变量输出语法都支持<code>filter</code>，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">span</span>&gt;</span>@(phoneNumber | secureMobilePhoneDisplay)<span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将会对<code>phoneNumber</code>这个变量调用<code>secureMobilePhoneDisplay</code>这个<code>filter</code>函数，可以将手机号变成<code>158xxxx1024</code>这样的格式。</p>
<p>这个功能非常实用，实现起来也不复杂，只需要对变量输出语法进行进一步解析就行了。对整个变量输出表达式按<code>|</code>进行<code>split</code>，然后把第一段当做输出源，后面都当做filter管道就行，filter可能带参数，比如<code>@(text | replace(/\d+/g, &#39;&gt;&gt;$0&lt;&lt;&#39;)</code>，需要对它进行进一步解析，具体不表……</p>
<p>当然麻烦之处也在于此，因为变量输出语法当中本身可能有一些表达式已经包含了<code>|</code>这个符号。而我们能做的则很有限，首先需要处理一下<code>||</code>运算符，这个可以用<code>split</code>结果推导也可以逐字分析，正则高手也许直接<code>split</code>就行。</p>
<p>但在遇到单个<code>|</code>的时候，就瞎逼了，它可能出现在字符串里，比如我们需要用<code>|</code>来拼面包屑或者做分隔符的时候；甚至可能是<strong>按位或运算符</strong>……前者的情况可以在模板里用HTML转义字符，后者的情况就让它瞎去吧。当然其实可以使用代码块或者数据预处理解决问题，不过还是求你饶前端一条小命吧。</p>
<h2 id="其他">其他</h2><h3 id="注释">注释</h3><p>这个太好用了，也是必须要有的，不然半月不见代码必瞎无疑。对于使用定界符的模板，一般来说都是前后<code>*</code>这样，比如<code>&lt;%*</code>和<code>*%&gt;</code>之间就是注释。</p>
<p>对于<strong>raze-tpl</strong>，这个也完全可行，<code>@* xxx *@</code>中间就可以是注释，当然既然语法这么骚，也可以实现一个单行注释，比如<code>@// xxxxx</code>这样，会更方便一些。</p>
<p>块注释实现很简单，就是当发现了一个“块注释开始”的模板语句时，parser立即进入“注释”状态，中间忽略一切内容，直到匹配到一个“块注释结束”语句为止。</p>
<h3 id="转义字符">转义字符</h3><p>对于使用定界符的模板，转义字符可有可无，毕竟<code>&lt;%</code>/<code>%&gt;</code>这类的东西正常代码里是比较难找的。但对于<strong>raze-tpl</strong>来说，因为它的<strong>leading char</strong>只有<code>@</code>这么简单，还是挺容易重的，比如email里就有，所以我安排了两个转义字符，一个是<code>@@</code>转义为<code>@</code>，一个是<code>@}</code>转义为<code>}</code>。尤其是后者，在括号匹配的时候要特殊处理一下，不要把它当模板语法结构里面的<code>}</code>给处理了。</p>
<h3 id="literal_block">literal block</h3><p>以Smarty为例，很多人应该遇到过这样的问题，把定界符设置位了<code>&#123;&#123;</code>和<code>&#125;&#125;</code>，结果当模板里内联了一段JS或者CSS（而且它还是被压缩过的）的时候就很容易瞎。于是Smarty就弄了一个<strong>literal block</strong>，里面的所有东西都会被当纯文本，不会解析为模板。</p>
<p>实现<strong>literal block</strong>的方式和实现<strong>块注释</strong>几乎一样，不再赘述。</p>
<p><strong>raze-tpl</strong>里实现了<code>@# xxx #@</code>作为<strong>literal block</strong>，聊胜于无。</p>
<h2 id="小结_&amp;&amp;_总结">小结 &amp;&amp; 总结</h2><p>到此为止，可以说已经可以造出一个全功能的模板引擎轮子，事实上所谓<em>“纸上得来终觉浅，绝知此事要<del>宫刑</del>躬行”</em>，光说不练还是不如真正造起轮子来过瘾。</p>
<p>可以发现模板引擎虽然是“前端”轮子，但是对狭义的前端技术——也就是HTML/JS/CSS这些——涉及甚少，基本上说除了用JavaScript以外，跟前端没啥关系其实。<del>所以换种语言接着再造一个也可以啊（¯﹃¯）</del></p>
<p>不过为了对生产的<code>render</code>函数进行惨无人道的优化，还是需要用到一些JS的奇技淫巧的，比如对古老浏览器拼接字符串的优化；比如通过变量解析，提前变量声明来做到更快速的变量访问；或者做到<strong>etpl</strong>那样的“安全变量访问”；也可能是像上文中所说的在实现函数定义的时候充分借助JS自带闭包特性等等——这提示我们：选择一门语言来实现模板引擎的时候，模板语言本身的语言特性设定也是从这个实现语言出发的，这样实现的时候会事半功倍，在“学习模板语言”的时候面对的“概念冲击”也会更少。</p>
<p><del>然后吐槽一下：hexo什么尼玛代码染色，风骚的语法尽毁。</del></p>
<p><del>好了我要开始想我的下一个轮子了……（逃</del></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接<a href="/2015/07/27/make-a-js-tpl-engine--code-gen/">上篇</a>、<a href="/2015/07/22/make-a-js-tpl-engine--parsing/">上上篇</a>和<a href="/2015/07/13/make-a-js-tpl-engine/">上上上篇</a>，这一篇将介绍一些模板语言的<strong>feature</strong>怎么实现，不会都说，会介绍一些比较重要的，思路优先，代码不多。</p>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[来吧，造个模板引擎轮子——目标代码生成]]></title>
    <link href="http://jimliu.net/2015/07/27/make-a-js-tpl-engine--code-gen/"/>
    <id>http://jimliu.net/2015/07/27/make-a-js-tpl-engine--code-gen/</id>
    <published>2015-07-27T12:13:23.000Z</published>
    <updated>2015-07-28T03:08:27.000Z</updated>
    <content type="html"><![CDATA[<p>接<a href="/2015/07/22/make-a-js-tpl-engine--parsing/">上篇</a>和<a href="/2015/07/13/make-a-js-tpl-engine/">上上篇</a>，这一篇将介绍在上一篇区分出“模板语言”与“自然语言”的结构之后，如何进行“语法分析”、“语义分析”和“目标代码生成”。</p>
<p>这里几个关键词都加了引号，主要是因为和经典编译原理上定义的几个环节只是意合而非形同，不过用这样经典的三段式结构来打比方也许可以更好理解一些。</p>
<a id="more"></a>
<h2 id="语法分析">语法分析</h2><p>我们还是用上一篇文章中的例子</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"list"</span>&gt;</span><br><span class="line">    &lt;% <span class="keyword">if</span> (<span class="type">list</span>.<span class="property">length</span> &gt; <span class="number">0</span>) %&gt;</span><br><span class="line">        &lt;% foreach <span class="property">item</span> <span class="keyword">in</span> <span class="type">list</span> %&gt;</span><br><span class="line">            &lt;p&gt;Hello, &lt;%= <span class="property">item</span>.<span class="property">name</span> %&gt;&lt;/p&gt;</span><br><span class="line">        &lt;% /foreach %&gt;</span><br><span class="line">    &lt;% /<span class="keyword">if</span> %&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>它的解析结果是</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">自然 &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"list"</span>&gt;</span><br><span class="line">模板 &lt;% <span class="keyword">if</span> (<span class="type">list</span>.<span class="property">length</span> &gt; <span class="number">0</span>) %&gt;</span><br><span class="line">模板 &lt;% foreach <span class="property">item</span> <span class="keyword">in</span> <span class="type">list</span> %&gt;</span><br><span class="line">自然 &lt;p&gt;Hello,</span><br><span class="line">模板 &lt;%= <span class="property">item</span>.<span class="property">name</span> %&gt;</span><br><span class="line">自然 &lt;/p&gt;</span><br><span class="line">模板 &lt;% /foreach %&gt;</span><br><span class="line">模板 &lt;% /<span class="keyword">if</span> %&gt;</span><br><span class="line">自然 &lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>为了减少干扰，我们先只看当中的模板语言部分</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (<span class="type">list</span>.<span class="property">length</span> &gt; <span class="number">0</span>) %&gt;</span><br><span class="line">&lt;% foreach <span class="property">item</span> <span class="keyword">in</span> <span class="type">list</span> %&gt;</span><br><span class="line">&lt;%= <span class="property">item</span>.<span class="property">name</span> %&gt;</span><br><span class="line">&lt;% /foreach %&gt;</span><br><span class="line">&lt;% /<span class="keyword">if</span> %&gt;</span><br></pre></td></tr></table></figure>
<p>严格的说，我们需要将这个代码序列构建成一棵<strong>语法树</strong>，也就是常说的<strong>AST（Abstract Syntax Tree）</strong>。但因为模板语言的语法结构通常都很简单，而且我们用的也是手写的办法，这里我们就用一种很直观的方法，对它<strong>直接进行语法、语义两部合一的分析</strong>。</p>
<p>遍历这个序列，解析每一句模板语句的内容，对<code>if</code>/<code>foreach</code>这些语句使用匹配算法。注意<code>else</code>和<code>elseif</code>是一个比较特殊的情况。</p>
<p>由于有了匹配关系，事实上可以在过程中保留匹配深度，这样甚至直接已经可以构建AST了。<strong>匹配关系对于代码生成并不是必须的</strong>，因为对于合法的模板代码，我们甚至只需要对它进行直译就能生成目标代码。但很多模板语法的特性是很依赖这个的（后面会说），于是乎还是有匹配关系才能可持续发展。</p>
<p>对于一些表达式这类的东西，比如<code>item.index + 1</code>，本来也应该对其构建AST，但模板语言既然脱胎于某种语言（比如我们现在的JS），就可以发挥这个优势，对于表达式，直接当成JS代码看就行（这个在下面生成目标代码的时候会详细的说）。</p>
<p>举个例子，当看到上面第三行<code>&lt;%= item.name %&gt;</code>的<code>=</code>时，说明这句话是输出一个表达式的，那么具体这个表达式是什么其实可以不关心（当然也许为了优化是需要关心的，这个以后会专门说），直接把它当做一坨整体来看待就行。</p>
<p>而对于一些相对复杂点的模板语言，比如Smarty，它在早期的时候定义了好多表达式语法，比如什么<code>$something eq &quot;1&quot;</code>这种，而后来的版本又支持以几乎和PHP一模一样的语法来写<code>$something == &quot;1&quot;</code>了，简直是蛋疼，我都不想说它……</p>
<p>所以对于每一句模板语法，在对它进行解析中都要知道它哪一部分是可以看成“表达式”的，例如<code>if (表达式)</code>、<code>foreach 变量名 in 表达式</code>。</p>
<p>将上面的分析工作做完以后通常都会获得一个程序内用的数据结构，可能是AST，也可能还是一个顺序表，比如</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>语句，表达式<span class="escape">`l</span>ist.length &gt; <span class="number">0</span><span class="escape">`</span><br><span class="line"></span>foreach语句，变量名<span class="escape">`i</span>tem<span class="escape">`，</span>表达式<span class="escape">`l</span>ist<span class="escape">`</span><br><span class="line"></span>变量输出语句，表达式<span class="escape">`i</span>tem.name<span class="escape">`</span><br><span class="line"></span>/foreach语句</span><br><span class="line">/<span class="keyword">if</span>语句</span><br></pre></td></tr></table></figure>
<p>然后在不考虑实现更多功能的情况下，已经可以用它进行代码生成了。</p>
<h2 id="代码生成">代码生成</h2><p>代码生成可以用非常简单实用的办法，就是直译，比如将<code>&lt;% if (xxx) %&gt;</code>直译为<code>if (xxx) {</code>，将<code>&lt;% foreach item in list %&gt;</code>直译为<code>for (var i=0, len=list.length; i&lt;len; i++) { var item = list[i];</code>，而<code>&lt;% /foreach %&gt;</code>和<code>&lt;% /if %&gt;</code>就直译为<code>}</code>；而那些“自然语言”和变量输出语句则当做字符串拼接。这样，上面的代码可能就变成了（加点缩进“美化”一下）</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var html = '';</span><br><span class="line">html += '&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"list"</span>&gt;';</span><br><span class="line"><span class="keyword">if</span> (<span class="type">list</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (var i=<span class="number">0</span>, len=<span class="type">list</span>.<span class="property">length</span>; i&lt;len; i++) &#123;</span><br><span class="line">        var <span class="property">item</span> = <span class="type">list</span>[i];</span><br><span class="line">        html += '&lt;p&gt;Hello, ';</span><br><span class="line">        html += <span class="property">item</span>.<span class="property">name</span>;</span><br><span class="line">        html += '&lt;/p&gt;';</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">html += '&lt;/<span class="keyword">div</span>&gt;';</span><br></pre></td></tr></table></figure>
<p>哈哈，粗看之下已经可以运行了啊，很简单无脑有没有。注意，因为<code>html</code>、<code>i</code>、<code>len</code>这样的变量名很可能是会被用户用的，所以实际这个环节我们要弄一个“变量名生成器”，生成一堆犄角旮旯的变量名，来保证不会和用户代码中的变量名重了。</p>
<p>呃，等等，<code>list</code>这个变量名，没定义过啊，因为我们传进来这个函数的是一个<code>data</code>对象，而上面用到这个<code>list</code>其实是它的某一个字段，所以应该访问<code>data.list</code>才是对的。但那样的话满世界的<code>data.</code>很让人心烦（当然不care这个事情的话下面的心思也不用花了），所以我们要解决一个变量访问的办法。</p>
<p>这里介绍两种思路，一种是用类似于<strong>etpl</strong>的“安全变量访问”，将表达式解析为一个变量访问函数的调用，比如<code>item.name</code>就被解析成了<code>get_variable([&#39;item&#39;, &#39;name&#39;])</code>，这样做其实有一定的局限性，比如用索引方式访问<code>item[&#39;name&#39;]</code>怎么算呢？要处理还是不处理？再比前文当中提到的变量作用域的问题（当然可以不提供或者有限提供变量声明语法来规避这个问题）嗯，还挺纠结的呢是不是。</p>
<p>另一种方法是将代码中可能成为变量名的内容提取出来，比如上述的模板片段中就会有<code>list</code>、<code>length</code>、<code>item</code>、<code>name</code>这几个，然后将他们提前定义一下。例如上面的代码就会变成</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var <span class="type">list</span> = data['<span class="type">list</span>'];</span><br><span class="line">var <span class="property">length</span> = data['<span class="property">length</span>'];</span><br><span class="line">var <span class="property">item</span> = data['<span class="property">item</span>'];</span><br><span class="line">var <span class="property">name</span> = data['<span class="property">name</span>'];</span><br><span class="line">var html = '';</span><br><span class="line">html += '&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"list"</span>&gt;';</span><br><span class="line"><span class="keyword">if</span> (<span class="type">list</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (var i=<span class="number">0</span>, len=<span class="type">list</span>.<span class="property">length</span>; i&lt;len; i++) &#123;</span><br><span class="line">        var <span class="property">item</span> = <span class="type">list</span>[i];</span><br><span class="line">        html += '&lt;p&gt;Hello, ';</span><br><span class="line">        html += <span class="property">item</span>.<span class="property">name</span>;</span><br><span class="line">        html += '&lt;/p&gt;';</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">html += '&lt;/<span class="keyword">div</span>&gt;';</span><br></pre></td></tr></table></figure>
<p>可以发现虽然定义了一大堆，但其实只有<code>list</code>是被正确使用的，<code>length</code>和<code>name</code>其实是没用的，而<code>item</code>则是被后来定义的又给盖了。</p>
<p>然后对上面的函数套一些胶水代码，比如</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上面那一堆</span></span><br><span class="line">    <span class="keyword">return</span> html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，现在这货是个字符串，我们需要用<code>new Function</code>或者<code>eval</code>的方式来把它弄成前文所说的<code>render</code>函数，然后对<code>render</code>函数传入<code>data</code>参数就大功告成了。</p>
<h2 id="代码生成中的优化">代码生成中的优化</h2><h3 id="字符串拼接">字符串拼接</h3><p>模板引擎本质上就是一个拼字符串的工具，毫无疑问，字符串拼接是模板引擎所生成的代码质量的一个核心因素。上面的例子当中直接使用字符串连接，在V8里是非常快的。如果你的代码想要对IE67进行优化，建议对老版本的IE生成<code>push</code>到数组然后最终<code>join</code>的办法。我记忆中IE8还是9以后字符串连接就比<code>join</code>要快了。</p>
<h3 id="循环语句的生成">循环语句的生成</h3><p>我们知道在JS里面遍历数组和遍历KV对象是不一样的，对于上面的例子我们生成的是遍历数组的代码，但事实上很多模板引擎都用一个<code>foreach</code>语法提供了两种功能。</p>
<p>最简单的办法是：生成两份代码，判断遍历目标是数组/KV对象的时候分别执行，例如</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="params">(isArray<span class="params">(xxxxxx)</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 一份完整的遍历数组的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(isObject<span class="params">(xxxxxx)</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 一份完整的遍历KV的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此之前，考虑到<code>xxxxxx</code>这个表达式可能访问起来有代价，可以先定义一个临时变量对它进行一下“缓存”。</p>
<p>对于遍历KV对象，如果愿意要求传入参数只能是plain object，那么可以预先用<code>Object.getOwnPropertyNames</code>获取到它所有的key，然后用遍历数组的办法来遍历，这个方法（至少在V8下）比直接用<code>for in</code>要快不少，但因为对于带原型的对象，<code>Object.getOwnPropertyNames</code>和<code>for in</code>之间会因为原型上的属性（甚至可能是用defineProperty定义的属性）而表现的很不一致，多数情况下使用<code>for in</code>会更稳妥一些。</p>
<h2 id="小结">小结</h2><p>到了这里，除了函数声明/调用外，我们几乎已经有了一个能用的模板引擎了，它能够支持</p>
<ul>
<li>变量输出</li>
<li>循环</li>
<li>条件</li>
</ul>
<p>下篇文章也许是这个系列最后一篇了，将会介绍如何实现包括函数声明/调用在内的更多feature。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接<a href="/2015/07/22/make-a-js-tpl-engine--parsing/">上篇</a>和<a href="/2015/07/13/make-a-js-tpl-engine/">上上篇</a>，这一篇将介绍在上一篇区分出“模板语言”与“自然语言”的结构之后，如何进行“语法分析”、“语义分析”和“目标代码生成”。</p>
<p>这里几个关键词都加了引号，主要是因为和经典编译原理上定义的几个环节只是意合而非形同，不过用这样经典的三段式结构来打比方也许可以更好理解一些。</p>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[来吧，造个模板引擎轮子——模板文件解析]]></title>
    <link href="http://jimliu.net/2015/07/22/make-a-js-tpl-engine--parsing/"/>
    <id>http://jimliu.net/2015/07/22/make-a-js-tpl-engine--parsing/</id>
    <published>2015-07-22T12:13:23.000Z</published>
    <updated>2015-07-23T05:02:14.000Z</updated>
    <content type="html"><![CDATA[<p>接<a href="/2015/07/13/make-a-js-tpl-engine/">上篇</a>，这一篇将介绍JS模板引擎是如何区分出“自然语言”和“模板语言”、以及如何进一步解析“模板语言”，最终我们需要拿到详细的模板语句结构。</p>
<p>这里说的“自然语言”就是只要生成的目标文件，比如HTML/XML；“模板语言”就是……模板语言了。</p>
<a id="more"></a>
<h2 id="定界符式的语法">定界符式的语法</h2><h3 id="区分模板语言与自然语言">区分模板语言与自然语言</h3><p>对于定界符式的语法，因为定界符通常都是一些犄角旮旯的符号，比如<code>&lt;%</code>/<code>%&gt;</code>这些符号是很难出现在正常的代码里面的。于是这种类型的模板语言，要从自然语言里面区分出来模板语言比较容易，这里介绍一种简单粗暴但实用的办法。以下面这一段代码为例。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"list"</span>&gt;</span><br><span class="line">    &lt;% <span class="keyword">if</span> (<span class="type">list</span>.<span class="property">length</span> &gt; <span class="number">0</span>) %&gt;</span><br><span class="line">        &lt;% foreach <span class="property">item</span> <span class="keyword">in</span> <span class="type">list</span> %&gt;</span><br><span class="line">            &lt;p&gt;Hello, &lt;%= <span class="property">item</span>.<span class="property">name</span> %&gt;&lt;/p&gt;</span><br><span class="line">        &lt;% /foreach %&gt;</span><br><span class="line">    &lt;% /<span class="keyword">if</span> %&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p><strong>首先用左定界符，这里就是<code>&lt;%</code>，对输入代码进行一次<code>split</code></strong>，可以得到如下的结果（为了“美化”文章我把无用的空格先去了）</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"list"</span>&gt;</span><br><span class="line"><span class="keyword">if</span> (<span class="type">list</span>.<span class="property">length</span> &gt; <span class="number">0</span>) %&gt;</span><br><span class="line">foreach <span class="property">item</span> <span class="keyword">in</span> <span class="type">list</span> %&gt; &lt;p&gt;Hello,</span><br><span class="line">= <span class="property">item</span>.<span class="property">name</span> %&gt;&lt;/p&gt;</span><br><span class="line">/foreach %&gt;</span><br><span class="line">/<span class="keyword">if</span> %&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>对于上面每一段，查看它是否包含右定界符<code>%&gt;</code></p>
<ul>
<li>如果不包含右定界符，那么将这段话以<strong>自然语言</strong>处理。<br>一般来说，它只会是整个源代码的第一段，否则你就会发现它其实是一个找不到与之匹配的空头（跟股票神马的没关系）。</li>
<li>如果包含右定界符，将这段话以它拆分，左边一段是一条<strong>模板语言</strong>，右边一段以<strong>自然语言</strong>处理。</li>
</ul>
<p>经过上面步骤，刚才那些就成为了下面的结果（为了“美化”文章，我给<strong>模板语言</strong>都加了定界符，这样看起来不会太违和）。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">自然 &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"list"</span>&gt;</span><br><span class="line">模板 &lt;% <span class="keyword">if</span> (<span class="type">list</span>.<span class="property">length</span> &gt; <span class="number">0</span>) %&gt;</span><br><span class="line">模板 &lt;% foreach <span class="property">item</span> <span class="keyword">in</span> <span class="type">list</span> %&gt;</span><br><span class="line">自然 &lt;p&gt;Hello,</span><br><span class="line">模板 &lt;%= <span class="property">item</span>.<span class="property">name</span> %&gt;</span><br><span class="line">自然 &lt;/p&gt;</span><br><span class="line">模板 &lt;% /foreach %&gt;</span><br><span class="line">模板 &lt;% /<span class="keyword">if</span> %&gt;</span><br><span class="line">自然 &lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意，这里并没有考虑模板语法嵌套的问题</strong>，比如在Smarty里，其实是可以这样写的</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="preprocessor">%</span> <span class="keyword">if</span> $list[&#123;<span class="preprocessor">%</span> $key <span class="preprocessor">%</span>&#125;] == <span class="string">'1'</span> <span class="preprocessor">%</span>&#125;</span><br><span class="line">    &lt;div class=<span class="string">"first"</span>&gt;&lt;/div&gt;</span><br><span class="line">&#123;<span class="preprocessor">%</span> /<span class="keyword">if</span> <span class="preprocessor">%</span>&#125;</span><br></pre></td></tr></table></figure>
<p>注意第一行，在一组模板标签内，又嵌套了一组，用我们上面的那种处理逻辑，遇到这样的代码是会跪的。首先还是先按左定界符拆</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(空)</span></span><br><span class="line"><span class="keyword">if</span> $list[</span><br><span class="line">$key <span class="preprocessor">%</span>&#125;] == <span class="string">'1'</span> <span class="preprocessor">%</span>&#125;&lt;div class=<span class="string">"first"</span>&gt;&lt;/div&gt;</span><br><span class="line">/<span class="keyword">if</span> <span class="preprocessor">%</span>&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，第2行是不包含右定界符的，也许我们会把它当做自然语言，但事实上它并不是。而第3行中，有两个右定界符。</p>
<p>这种语法就要复杂一些，我想了一个简单的办法，不知道可不可行。就是对于包含右定界符的段，如果超过1个右定界符，则对应往前“捞回”一段，重新标记成模板语言。但这样依然有一个难处，就是在捞回之后，左边的<code>if $list[</code>与右边的<code>] == &#39;1&#39;</code>这两句话它们其实分别不是一句完整合法的模板语句，于是处理过程中必须把嵌套层级关系保留下来，在后面构建语法树的时候还会用得上（其实这也是Smarty为什么又大又慢的一个重要原因，逃）</p>
<h3 id="解析模板语言的语法">解析模板语言的语法</h3><p>这个环节包含两个步骤，一个是处理每一条模板语句自身的内容，一个是处理他们的匹配关系。</p>
<p>回到刚才的例子，这次先忽略那些自然语言，只看其中的模板语句</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">模板 &lt;% <span class="keyword">if</span> (<span class="type">list</span>.<span class="property">length</span> &gt; <span class="number">0</span>) %&gt;</span><br><span class="line">模板 &lt;% foreach <span class="property">item</span> <span class="keyword">in</span> <span class="type">list</span> %&gt;</span><br><span class="line">模板 &lt;%= <span class="property">item</span>.<span class="property">name</span> %&gt;</span><br><span class="line">模板 &lt;% /foreach %&gt;</span><br><span class="line">模板 &lt;% /<span class="keyword">if</span> %&gt;</span><br></pre></td></tr></table></figure>
<p>先是对于每一条语句本身，需要进行一定的解析，这个阶段暂时只需要对它定性就可以，比如上面几条分别是</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>代码块<span class="keyword">open</span></span><br><span class="line"><span class="keyword">foreach</span>代码块<span class="keyword">open</span></span><br><span class="line">变量输出</span><br><span class="line"><span class="keyword">foreach</span>代码块<span class="keyword">close</span></span><br><span class="line"><span class="keyword">if</span>代码块<span class="keyword">close</span></span><br></pre></td></tr></table></figure>
<p>当中不难发现，<code>if</code>和<code>/if</code>，<code>foreach</code>和<code>/foreach</code>是有匹配关系的，而<code>&lt;%= item.name %&gt;</code>是没有匹配关系的。这样我们需要对刚才输出的语句列表进行一次解析，构造一棵“语法树”。这里之所以要加引号，是因为我们并不需要真正建立起来语法树，至于为什么，也许要下一篇才能具体讲明白，这里就先卖个关子了。</p>
<p>那么我们先只看对应关系，这个很简单，只需要对上面应用一次括号匹配就行了，当然这里匹配的不是括号，而是<code>if</code>和<code>/if</code>，<code>foreach</code>和<code>/foreach</code>这种对应的语句结构。括号匹配的算法是入门级的，就不赘述了。不过过程中可能需要一些特殊处理，比如<code>if/elseif/else</code>这样的组合并不是简单的对称地匹配就能解决的，但这并不难，事实上到了实际如果你真的要造个轮子你一定会有办法的（逃</p>
<h2 id="raze-tpl非定界符式的语法">raze-tpl非定界符式的语法</h2><p>因为我的raze-tpl轮子采用的是类似于微软大法的Razor语法，这种语法非常“骚”，下面我们把上述模板代码转换成对应的raze-tpl语法</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"list"</span>&gt;</span><br><span class="line">    @<span class="keyword">if</span> (<span class="type">list</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        @foreach (<span class="property">item</span> <span class="keyword">in</span> <span class="type">list</span>) &#123;</span><br><span class="line">            &lt;p&gt;Hello, @(<span class="property">item</span>.<span class="property">name</span>)&lt;/p&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到没有明显的定界符了，起码是干净了不少的。当然，如果你把<code>@</code>（在raze-tpl暂时把它叫做<strong>leading char</strong>）当做定界符，再套一下上面的那种算法，似乎……</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"list"</span>&gt;</span><br><span class="line"><span class="keyword">if</span> (<span class="type">list</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">foreach (<span class="property">item</span> <span class="keyword">in</span> <span class="type">list</span>) &#123;&lt;p&gt;Hello,</span><br><span class="line">(<span class="property">item</span>.<span class="property">name</span>)&lt;/p&gt; &#125; &#125;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>对于其中的每一段，需要再进行一下对应的语法检测一下它是不是满足某种模板语句类型，才能确定它是不是模板语句，例如</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">自然语言            &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"list"</span>&gt;</span><br><span class="line">@<span class="keyword">if</span>条件代码块open   <span class="keyword">if</span> (<span class="type">list</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">@foreach代码块open foreach (<span class="property">item</span> <span class="keyword">in</span> <span class="type">list</span>) &#123;&lt;p&gt;Hello,</span><br><span class="line">@()               变量输出代码块&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这还没有结束，因为上面的那些模板语句当中，明显还夹杂了自然语言，于是乎依然需要对它进行进一步分析，也就是说，上面的“解析模板语言的语法”这一步是提前了。</p>
<p><strong>这样做头会很晕</strong>，于是我用了一个听起来比较笨，但是实现更简单，可控性也更高的方法：<strong>逐字parse</strong>。</p>
<p>回到源代码</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"list"</span>&gt;</span><br><span class="line">    @<span class="keyword">if</span> (<span class="type">list</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        @foreach (<span class="property">item</span> <span class="keyword">in</span> <span class="type">list</span>) &#123;</span><br><span class="line">            &lt;p&gt;Hello, @(<span class="property">item</span>.<span class="property">name</span>)&lt;/p&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>以字符为单位，对上面的代码进行遍历</p>
<ol>
<li>在遇到<code>@</code>(leading char)之前，一切内容都当自然语言</li>
<li>遇到<code>@</code>，进行如下判断<br>3.1. 它的后续是否是转义字符，如<code>@@</code>转义成<code>@</code><br>3.2. 它的后续是否是括号，如<code>@(item.name)</code>中的<code>(</code><br>3.3. 它的后续是否是raze-tpl语法关键字，如<code>@if</code>、<code>@foreach</code></li>
<li>在上一步当中，根据判断出的类型，把源代码交给对应的处理器（Handler），处理代码块</li>
<li>Handler处理结束后，遍历的游标已经被Handler挪到代码块结束点，把遍历状态改回自然语言状态</li>
<li>继续遍历，直到遇到下一个<code>@</code></li>
</ol>
<p>不难发现一个重要的点：<strong>步骤3、4是递归的</strong>。</p>
<p>以上面的代码为例</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"list"</span>&gt; 自然语言</span><br><span class="line">@<span class="keyword">if</span>代码块 递归</span><br><span class="line">    @foreach代码块 递归</span><br><span class="line">        &lt;p&gt;Hello, 自然语言</span><br><span class="line">        @(<span class="property">item</span>.<span class="property">name</span>) 变量输出 不需要递归</span><br><span class="line">                     但需要解析这一条语句，结束后遍历游标移动到反括号`)`</span><br><span class="line">        &lt;/p&gt; 自然语言</span><br><span class="line">    &#125; &lt;- foreach代码块所对应的反花括号，foreach代码块结束，遍历游标移动到此</span><br><span class="line">&#125; &lt;- <span class="keyword">if</span>代码块所对应的反花括号，<span class="keyword">if</span>代码块结束，遍历游标移动到此</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt; 自然语言</span><br></pre></td></tr></table></figure>
<p>由于每一种类型、每一种模板语法关键字都有自己对应的语法结构和逻辑，因此在上面的递归过程中同时完成了上述“匹配、自身解析、遍历（递归）”这3件事情。这个过程大体上说就是编译原理当中的递归下降分析法的思路。</p>
<p>因为需要在高阶代码（JS）层面进行字符串遍历，而用<code>split</code>的办法仅仅需要在低阶（引擎内置函数）层面上操作，这种办法运行速度肯定是会比<code>split</code>要慢的。但如前作考虑，在服务端使用的时候，可以缓存编译结果，编译过程是一次性的，影响不大；在浏览器端使用的时候，如果当真遇到编译影响了运行速度和体验，可以考虑使用art-template类似的模板预编译方式。总之编译这件事情，速度上并没有太重要，也许在某些大工程里编译速度很重要，但对我们这些模板它也不可能会太大。</p>
<p>而编译器的小小性能损失却换来了灵活性还有这么骚的语法，还是很好玩的！</p>
<h2 id="小结">小结</h2><p>这篇文章讲了对于两种风格的模板语法，如何对它进行“词法分析”和“语法分析”，这里加引号，还是因为模板语言是一种混合语言，对它进行处理的时候与直接造一个某种语言的编译器还是有很大的区别的，尽管思路还是源于编译原理。</p>
<p>不过事实上这种规模的parser，手写比机写（通过parser generator生成）相比反而还要容易些。而且手写的高可控也更方便我们进行下一步工作，也就是下一篇文章要写的内容——生成render函数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接<a href="/2015/07/13/make-a-js-tpl-engine/">上篇</a>，这一篇将介绍JS模板引擎是如何区分出“自然语言”和“模板语言”、以及如何进一步解析“模板语言”，最终我们需要拿到详细的模板语句结构。</p>
<p>这里说的“自然语言”就是只要生成的目标文件，比如HTML/XML；“模板语言”就是……模板语言了。</p>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不聊情怀聊游戏，「仙剑」越做越烂了吗，为什么？（长文多图）]]></title>
    <link href="http://jimliu.net/2015/07/20/is-pal-being-worse-and-worse/"/>
    <id>http://jimliu.net/2015/07/20/is-pal-being-worse-and-worse/</id>
    <published>2015-07-20T10:31:35.000Z</published>
    <updated>2015-07-21T02:44:12.000Z</updated>
    <content type="html"><![CDATA[<p>今天在知乎上看到这么一个问题：<a href="http://www.zhihu.com/question/23822777" target="_blank" rel="external">「仙剑」越做越烂了吗，为什么？</a>，感觉很有意思，作为老铁杆仙剑迷而后来又坚决弃坑的，我觉得并不是仙剑系列越做越烂，而是进步速度实在太太太慢，远远的被业界抛在了后面。</p>
<a id="more"></a>
<p>游戏的发展是非常非常快的，抛开时代背景谈优劣是没有太大意义的。为什么仙剑1是公认的佳作，而后续作品争议很大，直到今年的仙剑6，被批判成什么德行就不说了？我觉得最简单的办法就是看看仙剑各代与同期作品的比较就好。</p>
<p>类型不限于RPG，但一定都是有时代烙印的、标志性的游戏。对于我玩过的游戏我会加一两句点评，没玩过的就以放图为主了。</p>
<p>在开始之前必须强调一点就是我从来对游戏都尽量的不会去评价剧情“好不好”，因为这种事情太主观了。但是评价剧情在某些角度是可行的，比如剧本的容量，叙事手法，人物形象的刻画等等。</p>
<h2 id="仙剑1时代（1995）">仙剑1时代（1995）</h2><p>因为那时候我年龄还小，加上那个互联网不发达的时代了解各种游戏资讯是非常有限的，而且事实上我大概是96~97年才玩到仙剑1的，我实在不太想得起足够多的同期作品，尤其是外国的作品。</p>
<h3 id="轩辕剑外传：枫之舞（1995）">轩辕剑外传：枫之舞（1995）</h3><p><img src="/uploads/2015/games/枫之舞-1.jpg" alt="枫之舞"></p>
<p><img src="/uploads/2015/games/枫之舞-2.jpg" alt="枫之舞"></p>
<p>枫之舞比仙剑出来还早半年的样子，我也是在玩到仙剑之前玩到了枫之舞，枫之舞难度较高，我没玩多久就弃坑了。</p>
<p>以现在的眼光来看，枫之舞的画面可能比不过同期的仙剑1，内容方面剧情还是可圈可点，炼妖系统很不错，但是在那个攻略书都能卖出去的时代显得有点复杂了，另一个就是难度还是挺高的。</p>
<h3 id="幻世录（1995）">幻世录（1995）</h3><p><img src="/uploads/2015/games/幻世录-1.jpg" alt="幻世录"></p>
<p><img src="/uploads/2015/games/幻世录-2.jpg" alt="幻世录"></p>
<p>我知道幻世录其实更晚了，大概是97年玩了试玩版，98年才玩到完整版的。其实挺难相信这竟然是95年的游戏（我也查了半天资料确认这个事情）。幻世录内容比较丰富，日漫风格的美术在当时的国产游戏似乎不常见，算是佳作。去年我又重温了一遍，在看片尾制作群的时候发现人还相当少，说起来难道真的是当年的人比现在要勤奋吗？</p>
<h3 id="红色警戒（1996）">红色警戒（1996）</h3><p><img src="/uploads/2015/games/红警1-1.jpg" alt="红警1"></p>
<p><img src="/uploads/2015/games/红警1-2.jpg" alt="红警1"></p>
<p>依稀记得当时网吧（那时候叫电脑室）联机打红警的人很多，以当时的智商，红警1完全没有平衡性可言，谁先出核潜艇谁就能赢……</p>
<h3 id="其他">其他</h3><p>最终幻想6（1994）、上古卷轴2：匕首雨（1996）、梦幻之星4（1994）、幻想传说（1995）……</p>
<p>最终幻想6其实是非常非常优秀的作品，但是受限于平台，恐怕国内那时候的受众比PC小太多。</p>
<p>上述几个我只玩过最终幻想6，而且已经是多年以后，还没通关，其他没玩过就不说了。</p>
<h3 id="仙剑1">仙剑1</h3><p><img src="/uploads/2015/games/仙剑1-1.jpg" alt="仙剑1"></p>
<p><img src="/uploads/2015/games/仙剑1-2.jpg" alt="仙剑1"></p>
<p>这么一看国内的优秀作品还挺多（96年还有《金庸群侠传》问世）。受制于互联网不发达，游戏需要搞到盘就是个不小的问题，甚至我当时的仙剑和金庸还是用整盒整盒的软盘拷的（伟大的HD-COPY）。</p>
<p>另一个角度看，那时候欧美似乎没什么RPG的概念……日系游戏对PC的重视程度一向一般也是个问题，反而是<del>暗耻</del>光荣的游戏还挺受欢迎的。</p>
<p>仙剑1在同期完全不输，“仙+剑”的设定非常受欢迎，45°视角和美术设定都很棒，足够大的游戏容量和令人深刻的高难度迷宫让玩家花得上很多时间。</p>
<p>战斗系统可圈可点，包括投掷、合力、用毒、辅助魔法等各种完整的玩法，也创造了经典的“天罡战气+醉仙望月步”。遇敌用的是可见的方式而非踩地雷，神走位的苗头就是在那时候开始的……</p>
<p>叙事方面仙剑1的方法就是最传统的（那年代似乎只有这种了）对话框推动剧情，说实话也只有那个年代才有心思慢慢看对话。好在仙剑1的对话容量控制的还算不错，并没有太长的纯对白过程。人物形象刻画的深刻程度是非常出色的，李逍遥的人设定位非常好，一个平凡的小子有着不平凡的心，那时候的骚年们一定都会有代入感的（虽然其实李逍遥也是名角儿的后人，不过我觉得那都是后来才编的，仙剑1中暗示李逍遥是“李大侠”的后人，但整个游戏中，除了李大娘给他的包裹以外，他没有表现出任何侠二代的优势，也几乎不曾开挂）。支线方面只能说还行，主要是奖励都不够诱人……但是故事都对主线有一定补充，比如香兰秀兰支线、古董商支线、桃源村支线。</p>
<p>成为神作固然有机缘巧合，但佳作是肯定的了。</p>
<h2 id="仙剑2、3时代（2003）">仙剑2、3时代（2003）</h2><p>仙剑2在03年1月发布，同年8月发布了仙剑3，还是先看看同期作品……</p>
<h3 id="暗黑破坏神2：毁灭之王（2002）">暗黑破坏神2：毁灭之王（2002）</h3><p><img src="/uploads/2015/games/暗黑2-1.jpg" alt="暗黑2"></p>
<p><img src="/uploads/2015/games/暗黑2-2.jpg" alt="暗黑2"></p>
<p>惊为天人的一作，至今仍然有不低的人气。</p>
<h3 id="无冬之夜（2003）">无冬之夜（2003）</h3><p><img src="/uploads/2015/games/无冬之夜1-1.jpg" alt="无冬之夜1"></p>
<p><img src="/uploads/2015/games/无冬之夜1-2.jpg" alt="无冬之夜1"></p>
<p>“正统”DND游戏，对于智商低下的我而言难度很高，于是没通关，但是当时仍然给了我不少的震撼，因为我几乎是头一次见到这么复杂的游戏……而且无冬保持了那时代欧美RPG的一个非常重要的特色，就是无论技术上画风是如何的，他们的人设头像和UI都很好的延续了那种艺术风格，每一个头像和道具图标看起来都很精致漂亮。</p>
<h3 id="刀剑封魔录">刀剑封魔录</h3><p><img src="/uploads/2015/games/刀剑封魔录1-1.jpg" alt="刀剑封魔录1"></p>
<p>同期非常棒的国产佳作，打击感（当时还不流行说这个词）很好。美术也很棒，在3D趋势这么明显的时候还是坚持了精致的2D，并且在画风的设定和美术水平上都非常值得称赞。真是眼前一亮的作品啊。</p>
<h3 id="最终幻想10-2（2003）">最终幻想10-2（2003）</h3><p><img src="/uploads/2015/games/FFX-2-1.jpg" alt="最终幻想10-2"></p>
<p><img src="/uploads/2015/games/FFX-2-2.jpg" alt="最终幻想10-2"></p>
<p>杀马特10-2，因为平台原因很多国内PC玩家（包括我）玩不到。</p>
<h3 id="波斯王子：时之砂（2003）">波斯王子：时之砂（2003）</h3><p><img src="/uploads/2015/games/时之砂-1.jpg" alt="时之砂"></p>
<p><img src="/uploads/2015/games/时之砂-2.jpg" alt="时之砂"></p>
<p>波斯王子几乎是我最早玩到的PC游戏了（除了台球以外），当时美国亲戚从美帝带来了几个游戏，印象比较深刻的有DOOM，因为晕3D而没有玩下去，一个就是波斯王子。</p>
<p>当时其实不太清楚这个游戏叫波斯王子，我只知道这个游戏叫PRINCE.EXE（批阿艾嗯C依点依埃克斯依）。不过从片头能看出来这明显是一个英雄救美的游戏。这个游戏有很多让我印象深刻的地方，比如它的反盗版系统是设计了一个满地都是毒瓶的关，其中只有一个是正确的，而你必须按照提示查说明书第几页第几个英文字幕才能知道正确答案是什么。在玩过无数次第一关，而接下来就被毒死之后，我才发现运行另一个exe就是破解版。再比如它的生意是通过控制PC机箱喇叭来发出来的，后来我大学的时候也写了一个程序，用PC喇叭来演奏音乐，同时开着4台电脑，演奏了《小星星》和《超级玛丽》，真是蛋疼。</p>
<p>我想我的动作游戏手残党基因那时候就体现出来了，因为我一直没有通关过，最好一次好像也只打到倒数第三关（其实当时并不知道到底有多少关）。</p>
<p>2003年《时之砂》的推出可以说是万众期待，时光倒流的玩法有点儿意思。尽管动作游戏苦手，我依然是<del>凭借着修改器</del>把它打完了。说来育碧还真是擅长做爬墙的游戏啊。</p>
<h3 id="魔兽争霸3：冰封王座（2003）">魔兽争霸3：冰封王座（2003）</h3><p>还用说吗……还用图吗……</p>
<h3 id="仙剑2">仙剑2</h3><p><img src="/uploads/2015/games/仙剑2-1.jpg" alt="仙剑2"></p>
<p><img src="/uploads/2015/games/仙剑2-2.jpg" alt="仙剑2"></p>
<p><img src="/uploads/2015/games/仙剑2-3.jpg" alt="仙剑2"></p>
<p>我还记得在那个等仙剑2等到长老茧的时期，某一期《大众软件》上刊登的仙剑2广告词：“等待，只是为了一场更凄美的感动。”还有典藏版的那个双鲤玉佩，呃，买不起。</p>
<p>这句话很好的反映了玩家的心情，但是最后仙剑2的确没做到这一点。</p>
<p>在那个可怜的中学生，省吃俭用的时代，仙剑2是寒假的时候我和两个堂哥“合资”买的——69的价格，20/20/29，因为我出了29，我理所应当的第一个玩咯。</p>
<p>几乎是早8晚12地玩了两三天（我妈竟然没有把我痛打一顿，真是亲妈），通关。没有什么感觉…………</p>
<p>以现在的眼光来看，仙剑2在同期算不上烂。如果不是《仙剑》，如果不是等了那么多年<del>这才几年，放暴雪爸爸那边根本不是事儿啊</del>，把它当做一款平常的国产游戏看，它也许承担了过多的骂名。但即使公平的看，它和同期的其他佳作相比，有什么能打的地方呢？</p>
<p>人设方面从仙剑2开始就非常明显的向日漫风格倾向了，原画和对话头像都是典型的日系尖下巴。其实在过(quān)渡(qián)作品《新仙剑》当中就已经有这个苗头，受限于仙剑1人设已经有了，不可能变太多，这个风格不明显。说实话我觉得日漫是好接受，但是仙1那种时代标志就没掉了。</p>
<p>战斗系统还是你拍一我拍一，不是秀优越感但我觉得回合制真的是快要过时了，其后的作品但凡有回合制基因的总要加一些别的元素，比如半即时、战棋等……</p>
<p>剧情……你妹的剧情，玩太快了根本就没印象剧情，除了从头到尾都觉得这个游戏应该改名字叫《魔刀奇侠传》以外……</p>
<h3 id="仙剑3">仙剑3</h3><p><img src="/uploads/2015/games/仙剑3-1.jpg" alt="仙剑3"></p>
<p><img src="/uploads/2015/games/仙剑3-2.jpg" alt="仙剑3"></p>
<p><img src="/uploads/2015/games/仙剑3-3.jpg" alt="仙剑3"></p>
<p>仙剑2过后仅仅半年就发布了仙剑3，毕竟制作周期有重叠。仙剑3是仙剑系列3D的首作，在这之前国产另一剑《轩辕剑4》就已经3D化，结果评价并不高，我个人也不喜欢，因为说实话那美术水平……</p>
<p>玩家和媒体对仙剑3的评价比仙剑2来的好太多了，我非常相信主要一个原因就是等待的原因很短，毕竟在经过仙剑2的失望之后没有多久就玩上了画面和系统焕然一新的续作。</p>
<p>相比轩4，仙剑3因为用了Q版人物，这让3D技术和美术上与同期国外佳作的差距变小了一点——你说画面不好，可以反驳你“画风不同”噎死你。但这好歹是个新的尝试，是个突破。</p>
<p>战斗方面使用了半即时，是个顺应潮流的选择，没什么创新就是了。玩法上有一些小游戏，比如鉴定、滑雪啥的，聊胜于无吧。</p>
<p>剧情方面没有实质性的进展，还是靠着对话框式推进，区别仅仅是某些游戏内演出因为3D的原因显得更加生动了一些……<del>剧情延续了中国武侠RPG两女共侍一夫的光荣传统，</del>角色的塑造方面我觉得紫萱虽然仅是女3号，但是她的角色形象比其他女猪脚甚至男猪脚景天还要深刻，也许这就是女娲光环的作用吧。</p>
<p>仙剑3是系列当中突破性的的一作，但是同期的其他好的作品真是论数量论质量都太够玩了，以至于仙剑3依然算不上同期的上乘之作，也许算是平均线的水平吧。</p>
<h2 id="仙剑4时代（2007）">仙剑4时代（2007）</h2><p>又是一个不短的等待，这个过程中我也从中学进入到了大学，在03年暑假家里装上宽带以后，互联网已经成了我生活中不能少的一部分，这个阶段开始我接触了更多的更棒的游戏（虽然还是很少），对于仙剑4的期待也越来越少，越来越不放心。因为同期的重量级佳作真是太…………多了。</p>
<h3 id="孤岛危机（2007）">孤岛危机（2007）</h3><p><img src="/uploads/2015/games/孤岛危机1-1.jpg" alt="孤岛危机1"></p>
<p><img src="/uploads/2015/games/孤岛危机1-2.jpg" alt="孤岛危机1"></p>
<p>显卡危机的名字是乱说的吗？你知道在那时候某个寝室的同学有一台能玩得动孤岛危机的笔记本电脑那是多么令人羡慕的事情吗？画面并不是游戏的全部，但是绝对是一个游戏能给人以震撼的最直接最深刻的一点。从孤岛惊魂到孤岛危机，老外的技术之强悍让我觉得国产游戏要在画面和美术上达到水准之上几乎是不可能的了。</p>
<h3 id="魔兽世界：燃烧的远征（2007）">魔兽世界：燃烧的远征（2007）</h3><p><img src="/uploads/2015/games/TBC-1.jpg" alt="魔兽世界：燃烧的远征"></p>
<p><img src="/uploads/2015/games/TBC-2.jpg" alt="魔兽世界：燃烧的远征"></p>
<p>魔兽世界是我非常非常喜欢的游戏，它的容量和分量真的对得起“世界”这个词。因为没有玩过60级版本，对旧世界有多大没有深刻印象。但至少在TBC版本我第一次学会飞行坐骑飞起来的时候，我真的是非常震撼，迫不及待地在地图上到处逛，到处截图，就这么玩了一下午——《魔兽世界：燃烧的点卡》。</p>
<p>如果孤岛危机的画面是技术压倒性的优势，那魔兽世界在画面上绝对是美术的胜利，即使在低配机器上开低画质，也能得到非常不错的游戏体验；而把画质开满的时候，虽然达不到3A级作品的水准，但也是在同期作品的水准了。我相信暴雪的美术一定是在不同的画质下都做了精心的调整才能有这样的成果。</p>
<p>直至今天国产3D游戏，包括使用国际大引擎的、也包括自研引擎的重量级作品，在静态画面方面也许的确能做到国际级水准，但是一旦进入到动态过程，就落了下风。首先是光照和材质上的问题，国外的大作真是非常善于制作各种有质感的材质。另一个是在动作采集和动画混合方面，比如那轻飘飘的跑步和转身（人家这叫轻功）、僵硬的武术动作、再到所谓的打击感，甚至今天的国产游戏在动作上也不如当年的魔兽世界来的自然流畅（而且魔兽世界也持续改进至今）。</p>
<h3 id="英雄传说：空之轨迹3rd（2007）">英雄传说：空之轨迹3rd（2007）</h3><p><img src="/uploads/2015/games/空之轨迹3rd-1.jpg" alt="英雄传说：空之轨迹3rd"></p>
<p><img src="/uploads/2015/games/空之轨迹3rd-2.jpg" alt="英雄传说：空之轨迹3rd"></p>
<p>在画面开始转向3D化后，日系RPG（甚至整个传统RPG类型）越来越势微，空轨系列延续了日系RPG精致的美术风格，2D场景3D人物。作为RPG也有足够容量的剧情，战斗也引入了半战棋的风格。各方面可以说都还不错，并没有和欧美的大作硬拼。具体的我因为玩到一半就期末考，就不多评价了。</p>
<h3 id="其他-1">其他</h3><h4 id="最终幻想12（2006）">最终幻想12（2006）</h4><p><img src="/uploads/2015/games/FFXII-1.jpg" alt="最终幻想12"></p>
<p><img src="/uploads/2015/games/FFXII-2.jpg" alt="最终幻想12"></p>
<h4 id="刺客信条（2007）">刺客信条（2007）</h4><p><img src="/uploads/2015/games/刺客信条1-1.jpg" alt="刺客信条"></p>
<p><img src="/uploads/2015/games/刺客信条1-2.jpg" alt="刺客信条"></p>
<h4 id="神秘海域（2007）">神秘海域（2007）</h4><p><img src="/uploads/2015/games/神秘海域1-1.jpg" alt="神秘海域"></p>
<p><img src="/uploads/2015/games/神秘海域1-2.jpg" alt="神秘海域"></p>
<p><img src="/uploads/2015/games/神秘海域1-3.jpg" alt="神秘海域"></p>
<p><img src="/uploads/2015/games/神秘海域1-4.jpg" alt="神秘海域"></p>
<p>因为我很喜欢这个系列就多几张图……</p>
<h3 id="仙剑4">仙剑4</h3><p><img src="/uploads/2015/games/仙剑4-1.jpg" alt="仙剑4"></p>
<p><img src="/uploads/2015/games/仙剑4-2.jpg" alt="仙剑4"></p>
<p><img src="/uploads/2015/games/仙剑4-3.jpg" alt="仙剑4"></p>
<p><img src="/uploads/2015/games/仙剑4-4.jpg" alt="仙剑4"></p>
<p><img src="/uploads/2015/games/仙剑4-5.jpg" alt="仙剑4"></p>
<p>这个……</p>
<p>在那时候我学业繁忙，无心游戏，于是仙剑4也是没玩通关就草草收场，好赖后来全程围观室友勉强补全。</p>
<p>其实以上是借口，真正原因是我根本对这个游戏没有信心，不相信它的水准了。</p>
<p>画面上看，落后了同期的国外大作至少一个时代，这一次我完全不能接受“画风不同”这种解释。那些空洞无味的场景似乎就是为了设置迷宫（系列传统）堆砌出来的。所有的贴图看起来似乎只有那么几种材质，似乎完全没有用一些先进的贴图技术来提高质感的味道。光照做得也很糟，似乎所有场景都是静态光照的。</p>
<p>战斗和3比没有实质的进展，因为真人比例3D，服装道具、武术动作都比3强多了，这个必须是进步。虽然就是些刀光剑影的特效，谈不上技术上的光影效果，但大招的华丽程度其实还可以。</p>
<p>剧情方面，首先人设我觉得存在感稀薄，一个是更加日漫倾向了（为什么我这么不喜欢国产RPG游戏的日漫人设？），一个是我不喜欢那些为了听起来很有仙侠味道而起得奇奇怪怪的角色名字（其实从仙剑3开始我就有吐槽这个的意思了，当然我也没觉得“王小虎”是一个好的主角名字……）也许是随着互联网的发展，见到的对比物多了，我认为仙剑4在剧情方面似乎就是一部也许还不错的网络小说的水平。</p>
<p>在叙事手法上，依然是无数的对话框，但是因为真人比例3D而对话，而演出甚少（挥挥手跺跺脚那不叫演出好吗），对话过程中人物大多数时候就如此呆滞着，造成对话框更加遭人厌恶，我愿意看剧情小说都不愿意看这些对话框，真的。</p>
<p>至于网上有很多人觉得仙剑4是神作的，我只能理解为也许他们优秀作品玩的太少，或者是人生若只如初见，亦或者如某些调查分析所言，一些玩家根本分辨不出游戏画面的好坏，进而也无法分辨游戏的好坏？</p>
<h2 id="仙剑5时代（2011）">仙剑5时代（2011）</h2><p>到这个时代我已经不再想做评价了，其实是因为仙剑5我根本没买也没玩……还是那句话，我根本对这个游戏没信心了。从宣传片和演示视频上看，我就已经对这个游戏没信心了。这就跟电影似的，如果宣传片都不吸引你，为什么要掏钱去电影院看呢（也只有我特么单身狗去电影院是看电影的）。</p>
<p>同期的作品也许是这样的：</p>
<p><img src="/uploads/2015/games/巫师2-1.jpg" alt="巫师2"></p>
<p><img src="/uploads/2015/games/巫师2-2.jpg" alt="巫师2"></p>
<p><img src="/uploads/2015/games/巫师2-3.jpg" alt="巫师2"></p>
<p><img src="/uploads/2015/games/巫师2-4.jpg" alt="巫师2"></p>
<p>或者是这样的：</p>
<p><img src="/uploads/2015/games/神秘海域3-1.jpg" alt="神秘海域3"></p>
<p><img src="/uploads/2015/games/神秘海域3-2.jpg" alt="神秘海域3"></p>
<p><img src="/uploads/2015/games/神秘海域3-3.jpg" alt="神秘海域3"></p>
<p>甚至是这样的：</p>
<p><img src="/uploads/2015/games/孤岛危机2-1.jpg" alt="孤岛危机2"></p>
<p><img src="/uploads/2015/games/孤岛危机2-2.jpg" alt="孤岛危机2"></p>
<p>至少是这样的：</p>
<p><img src="/uploads/2015/games/地牢围攻3-1.jpg" alt="地牢围攻3"></p>
<p><img src="/uploads/2015/games/地牢围攻3-2.jpg" alt="地牢围攻3"></p>
<p>而（再一次）等了4年的仙剑5则是这样的……</p>
<p><img src="/uploads/2015/games/仙剑5-1.jpg" alt="仙剑5"></p>
<p><img src="/uploads/2015/games/仙剑5-2.jpg" alt="仙剑5"></p>
<p><img src="/uploads/2015/games/仙剑5-3.jpg" alt="仙剑5"></p>
<p>看完宣传片，看完演示视频，我说我为什么要买？</p>
<h2 id="仙剑6（2015）">仙剑6（2015）</h2><p>又一个4年，这次，我该说什么呢？</p>
<h2 id="「仙剑」越做越烂了吗，为什么？">「仙剑」越做越烂了吗，为什么？</h2><p>我想说其实仙剑并没有越做越烂，仙剑其实应该说是越做越好了，但是它进步的速度实在是太慢了，20年时间，整个游戏工业全方位都发生了翻天覆地的变化，然而仙剑系列还是满满的情怀，以4年一迭代的速度（中间的外传比主线作品没有质变），完成别人半年的进化幅度。</p>
<p>尽管仙剑6也用了世界级的先进引擎，但技术和美术各方面匮乏都造成了它难以达到水准。建模的精度大大提高，但是材质贴图和光照水平还是那么的差，于是看到的效果也仅仅就是一个看起来更光滑的塑料小人儿，却因为建模的复杂而造成性能堪忧。殊不知老外早就用更先进的贴图技术，在更少的多边形上做出更漂亮的模型和材质，更别说那些先进的光照技术了。</p>
<p>我不想说这是技术差距还是用不用心的问题，毕竟用不用心只有他们自己知道。</p>
<h2 id="关于RPG的唠叨">关于RPG的唠叨</h2><p>我越来越相信，欧美的动作冒险/RPG游戏找到了新的方向。在《最终·杀马特·幻想》系列领衔日系RPG百花齐放的巅峰过去后，以人设为核心的RPG已经开始过时了。就算你有再错综复杂的人物关系，玩一个游戏已经很累了又怎么有心思去推敲呢？（这还得考虑RPG游戏时间普遍要比动作游戏长）</p>
<p>为什么《最后生还者》评价这么高？</p>
<p>我认为作为动作冒险游戏，它比RPG更擅长于讲故事。首先是主角的定位就是很普通的人，没有杀马特造型也没有炫酷的名字（毕竟人家没有修仙，笑），这一点先平衡了诸多玩家的口味问题。</p>
<p>其次是整个游戏完全围绕在简单的一两个人身上，剧情推荐过程中出现第三四个配角/反面，但都不会更多了<del>至少当要引入一个新配角的时候总会先把之前的搞死</del>，角色开会的现象几乎不存在（虽然《最后生还者》是末日游戏，本身世界上剩的人就不多……），中间没有配角的段落，男女猪脚的感情就会迅速升温<del>毕竟二人世界</del>，这让整个游戏在情节上显得很有节奏，这和一部好电影的叙事手法是有很多相似之处的。</p>
<p>另外就是优秀的游戏学会了使用Game Play来叙事，比如《最后生还者》当中Ellie逐渐敞开心扉给Joel讲冷笑话的互动玩法，直到最后Joel的真情告白；也比如《最后生还者》和《生化奇兵：无限》当中女猪脚战斗中给男猪脚提供补寄的行为；支线有时候就一些收集品就能完成一个游戏背景提示（比如字条、比如剪报、比如染血的衣服，比如《最后生还者》中捡到的那张全家福照片，背后写着“Forgive us”）；甚至场景也能叙事（比如《最后生还者》中大学破寝室楼的场景，外面是弥漫的真菌孢子，而旧寝室里当年学生的那些陈设和墙上贴的诸多照片、海报都还在，俨然一副温馨的样子，形成鲜明的对比，让你对这里发生过什么悲剧能有非常清晰的想象）……这些就已经是很明确的情感和剧情的暗示了，又何必强行安排很多生离死别碧落黄泉的情节呢？女猪脚受伤了，于是曾经的猪队友爆料某个神秘道具可以救人，然后大家就乐呵呵的继续去走迷宫、打怪、对话，遇到BOSS，救过来女猪脚，如此循环往复，当游戏时间达到二三十个小时以后，就可以安排最终BOSS了。而那些纯粹跑腿打怪收集，然后给你个道具奖励的支线，真的是更没什么意思了。</p>
<p>这么多年来，一直都在说游戏电影化，可是做的好的真不多。甚至大家觉得做的好的小岛秀夫，在《和平行者》当中也用了太多冗长的放动画片和念对白。RPG游戏这么庞大的剧情容量，做得不好就变成了肥皂剧。现在的生活节奏比过去快了太多，有些东西该变就会变，挡不住。</p>
<h2 id="题外话">题外话</h2><p>其实看到撞仙在微博上各种做推广，我并不开心，因为总是怀旧、总是情怀、总是感动，真的没什么意思。国产游戏的技术和美术实力都投到网游甚至手游上去了<del>还有给外国3A大作做外包</del>，这没办法，网游手游赚钱，做网游手游的公司自然愿意投入在这方面，工资高才能吸引人才对不？毕竟房价那么高，奶粉那么贵，总得活，是么？</p>
<p>但是总说什么支持国产、支持经典，什么感动、什么坚持，我不乐意。改革开放多少年了，早特么市场经济了，玩游戏需要花很多时间，玩游戏也需要花钱，这是对一款游戏的投资。谁值得我玩，我就支持谁。管你什么仙剑古剑轩辕剑……</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天在知乎上看到这么一个问题：<a href="http://www.zhihu.com/question/23822777">「仙剑」越做越烂了吗，为什么？</a>，感觉很有意思，作为老铁杆仙剑迷而后来又坚决弃坑的，我觉得并不是仙剑系列越做越烂，而是进步速度实在太太太慢，远远的被业界抛在了后面。</p>]]>
    
    </summary>
    
      <category term="站着说话不腰疼" scheme="http://jimliu.net/tags/%E7%AB%99%E7%9D%80%E8%AF%B4%E8%AF%9D%E4%B8%8D%E8%85%B0%E7%96%BC/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[来吧，造个模板引擎轮子——开篇]]></title>
    <link href="http://jimliu.net/2015/07/13/make-a-js-tpl-engine/"/>
    <id>http://jimliu.net/2015/07/13/make-a-js-tpl-engine/</id>
    <published>2015-07-13T10:31:35.000Z</published>
    <updated>2015-07-14T05:25:32.000Z</updated>
    <content type="html"><![CDATA[<p>来吧<del>战个痛</del>，造个模板引擎轮子。</p>
<p>是的，我又给自己挖了个新坑，这次虽然代码已经写了一两个月了，但是写码之余，意犹未尽。</p>
<p>我知道在MVVM代表着先进生产力的发展要求，并且也越来越流行的今天，字符串模板已经越来越势微。而且这玩意其实技术含量并不高，是“技巧 &gt; 技术”的类型。不过手痒得很，于是还是造了一个。</p>
<p>这次挖这个坑就是要为我的模板引擎轮子写一个开发心得<del>流水账</del>，暂时不知道会写多少篇，说不定两三篇，说不定一篇就变有生之年系列……</p>
<p>内容方面其实很枯燥，因为我不喜欢写一些高大上的设计思路这类的东西<del>都特么边写边删边想的哪有什么设计</del>，对于工作之外的玩意，我就喜欢写了删删了写，说好听点这叫<em>好读书，不求甚解</em>（掩面逃）。</p>
<p>哦，先丢个<a href="https://github.com/liuji-jim/raze-tpl" target="_blank" rel="external">GitHub</a>，继续做一个不负责任的男人，无测试、无DEMO、无主页的三无项目……为了尝鲜、玩票外加装逼，我用的是TypeScript来写，其实和JS也没啥差别。</p>
<a id="more"></a>
<h2 id="目标设定">目标设定</h2><h3 id="语法风格">语法风格</h3><p>说到模板引擎，很多人都会想到PHP当中的Smarty，这也许是前端用得最多的模板引擎了。Smarty代表了一种以“定界符”为核心的模板引擎语法，例如：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="expression">&#123;&#123;<span class="variable"><span class="keyword">if</span></span> $<span class="variable">xxx</span> == '<span class="variable">yyy</span>'&#125;&#125;</span><span class="xml"></span><br><span class="line">    Oh yeah....</span><br><span class="line"></span><span class="expression">&#123;&#123;<span class="end-block">/<span class="keyword">if</span></span>&#125;&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>
<p>这种语法风格，一直延续至今，广为人们所接受。我觉得这种风格之所以大家很容易接受，一个重要的原因就是它跟ASP/JSP/PHP本身所提供的语言内嵌功能是如此的相似，甚至还有<a href="https://larsjung.de/node-cgi/" target="_blank" rel="external">node-cgi</a>这么好玩的东西！！例如PHP：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="preprocessor">&lt;?</span> <span class="keyword">if</span> (<span class="variable">$xxx</span> == <span class="string">'yyy'</span>) &#123; <span class="preprocessor">?&gt;</span></span></span><br><span class="line">    Oh yeah...</span><br><span class="line"><span class="php"><span class="preprocessor">&lt;?</span> &#125; <span class="preprocessor">?&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>到了JS这边，众多流行的模板引擎，比如<a href="https://github.com/tj/ejs" target="_blank" rel="external">EJS</a>、<a href="https://github.com/wycats/handlebars.js" target="_blank" rel="external">handlebars</a>、<a href="https://github.com/janl/mustache.js" target="_blank" rel="external">mustuche</a>等，以及国内的（我觉得的）上乘之作<a href="https://github.com/ecomfe/etpl" target="_blank" rel="external">ETPL</a>、<a href="https://github.com/aui/artTemplate" target="_blank" rel="external">artTemplate</a>，都是沿用了定界符的语法风格。</p>
<p>这本身不是什么问题，用定界符可以很方便的从源代码当中区分出哪些是HTML，哪些是模板逻辑，这想必是极好的。但对于我来说，我却觉得不够“<strong>骚</strong>”，用<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B0%94%E7%9A%84%E7%A7%BB%E5%8A%A8%E5%9F%8E%E5%A0%A1" target="_blank" rel="external">哈尔</a>的话说就是</p>
<p><img src="/uploads/2015/not-beautiful.jpg" alt=""></p>
<p>说到骚的话，<a href="https://github.com/jadejs/jade" target="_blank" rel="external">Jade</a>其实是挺骚的一个模板引擎，但是我并不喜欢它。一个是因为我不喜欢用缩进来表示代码层级的语言（一黑一大片），我喜欢大括号！一个是在过去尝试用Jade的过程中，对于内联逻辑表达式实在是太头疼了……比如在Smarty当中：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="expression">&#123;&#123;<span class="variable">foreach</span> <span class="variable">from</span>=$<span class="variable">list</span> <span class="variable">item</span>=<span class="variable">it</span>&#125;&#125;</span><span class="xml"></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"list-item</span></span></span><span class="expression">&#123;&#123;<span class="variable"><span class="keyword">if</span></span> $<span class="variable">it.active</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="value"> active</span></span></span><span class="expression">&#123;&#123;<span class="end-block">/<span class="keyword">if</span></span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="value">"</span>&gt;</span></span><span class="expression">&#123;&#123;$<span class="variable">it.name</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"></span><span class="expression">&#123;&#123;<span class="end-block">/foreach</span>&#125;&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>
<p>的那段关于类名<code>active</code>的内联逻辑，这种丑到没朋友，但是简单粗暴能够解决问题让我不加班的代码，我竟然没研究出来Jade里怎么实现。虽然事情已经过去两年了，但这还是给我留下了巨大的心理阴影，我深信这一定是我太愚蠢了，Jade一定是可以做到的，但是我心塞了，心累了，没兴趣研究了。</p>
<p>后来当我回想起大学的时候用微软大法C#和ASP.NET MVC的时候，在发展到某个版本的时候，微软大法推出了一款<a href="https://github.com/aspnet/Razor" target="_blank" rel="external">Razor模板引擎</a>（他们管叫“Render Engine”）<del>当时我好像还不大喜欢它呢，其实只是因为我当时的项目已经到后期了不可能再换模板</del>。它的语法非常的简洁，对于逻辑代码块，它使用</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">@&#123;</span></span><br><span class="line">    <span class="preprocessor">code</span> <span class="keyword">block</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>的格式，相当于直接内联C#代码，简单粗暴<em>I&#39;m lovin&#39; it</em>啊……而对于变量输出，则更加简单了：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello! My name <span class="keyword">is</span> &lt;<span class="keyword">strong</span>&gt;@name&lt;/<span class="keyword">strong</span>&gt;. I<span class="attribute">'m</span> @age year<span class="attribute">'s</span> old.</span><br></pre></td></tr></table></figure>
<p>嗯……骚骚骚，骚不住！</p>
<h3 id="功能">功能</h3><p>要作为一个能用的模板引擎（我没有点名黑<a href="https://github.com/olado/doT" target="_blank" rel="external">doT</a>，其实我说的是早期的doT，简直除了快以外……），必须有完备的功能。但功能、性能、体积必然是一个难以取舍的平衡。考虑到我的轮子定位偏node.js端，体积可以放最后一位<del>（当然为了证明我偏执狂还装逼我还是会尽量把它写小一点）</del>。功能方面，至少对于我而言，需要以下<strong>必选</strong>功能：</p>
<ul>
<li>变量输出</li>
<li>循环</li>
<li>条件</li>
<li>函数定义/调用</li>
</ul>
<p>以及以下<strong>可选</strong>功能：</p>
<ul>
<li>变量输出filter</li>
<li>block定义与重写</li>
<li>模板继承（配合上面这个食用）</li>
<li>include</li>
</ul>
<p>对于前5点来说，其实都是很容易实现的需求。</p>
<p>其中<strong>函数</strong>这一块，在Smarty当中有一件很让人头疼的事情，那就是它的模板变量作用域。JS的闭包可以方便的在任何函数里访问当前词法上下文里的局部变量，这是非常方便的，而在PHP里则不行。Smarty自己设计了一个较为复杂的变量作用域系统，感觉吧，不是很好用，我反正没怎么闹得很明白。但在我的轮子里面我要让模板函数可以直接像JS一样，使用函数外层作用域当中的变量。</p>
<p>而对于后面3点，因为涉及到跨模板文件，这在浏览器端实现起来会很难受，比如artTemplate就用<code>#id</code>来搞的，我觉得吧，还是有点鸡肋。</p>
<p>考虑到我以娱乐为主，同时前面也说了，因为MVVM/React这类的东西存在，纯字符串模板引擎在浏览器端存在感越来越弱，那么这样的需求我就只实现在node.js端了，<code>fs.readFileSync</code>走起啊还犹豫什么……</p>
<h3 id="基本思路">基本思路</h3><p>模板语言简单地说其实就是一种DSL，模板引擎的作用就是解析、执行DSL。毫无疑问如果使用“解释执行”的办法，这多半是比较慢的。所以能见人的模板引擎一般都用的“编译执行”的办法，比如Smarty，它在第一次执行的时候把模板编译成PHP文件，后续再使用这个模板的时候就省了这一步，直到模板文件时间戳改变。</p>
<p>早年的JS模板引擎其实是没有编译功能的，因为很多人相信<em>Eval is Evil</em>，但前辈们经过实践出真知，通过<code>new Function</code>或者<code>eval</code>将模板编译成一个JS函数，在模板重复执行的过程中毫无疑问比每次都解析是快太多了，于是JS模板引擎的工作流程就成了：</p>
<ul>
<li>解析模板文件，将其构造成一段JS代码（内含大量字符串拼接）</li>
<li>将上面代码通过<code>new Function</code>或者<code>eval</code>构造成一个render函数</li>
<li>返回render函数，对其传入data参数即可返回一段渲染后的字符串</li>
</ul>
<p>例如EJS的用法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> render</span> = ejs.compile(str, options); <span class="comment">// 编译后的render函数</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> html</span> = render(data); <span class="comment">// 渲染结果</span></span><br></pre></td></tr></table></figure>
<p><strong>如何解析模板文件</strong>是第一步，对于使用定界符的模板语言，在不考虑bad case的情况下其实非常简单，就是直接通过按定界符进行<code>split</code>就能把模板语言和“自然语言”区分开来，对于模板语言进行进一步解析，对于“自然语言”则直接构造成字符串拼接就完事儿了。</p>
<p>但对于我的轮子而言，因为它的语法很骚，直接用定界符分割是很不靠谱的事情。所以我选择了使用手写（伪）Parser的办法来解析，解析速度上应该是会慢一些，不过也就几十毫秒的事儿了……几十毫秒在浏览器端会是一个挺严重的事情，可能会掉几帧，但在服务端则可以通过缓存编译结果来让它只在启动时发生一次，影响不大。如果在浏览器端应用会成问题，那么可以采用类似artTemplate的预编译法，不过<em>Done is better than perfect</em>，这些都是后话了。</p>
<hr>
<p>下一期节目当中就开始进入正题，写一下如何手写Parser将上述语法和功能需求构建成为目标代码。</p>
<!--
    首先是吃自己狗屎系列，我把我的博客原本基于[EJS](https://github.com/tj/ejs)的模板全部改为了使用自己的模板引擎。这个过程有点小煎熬，因为其实Hexo给输出到模板这一层的数据并不纯净，我所用的Light这个主题原本的EJS模板里夹杂了很多JS逻辑（可能这是早期主题的问题，也许较新的Hexo主题已经没这种问题了），不过好赖还是给克服了。
-->]]></content>
    <summary type="html">
    <![CDATA[<p>来吧<del>战个痛</del>，造个模板引擎轮子。</p>
<p>是的，我又给自己挖了个新坑，这次虽然代码已经写了一两个月了，但是写码之余，意犹未尽。</p>
<p>我知道在MVVM代表着先进生产力的发展要求，并且也越来越流行的今天，字符串模板已经越来越势微。而且这玩意其实技术含量并不高，是“技巧 &gt; 技术”的类型。不过手痒得很，于是还是造了一个。</p>
<p>这次挖这个坑就是要为我的模板引擎轮子写一个开发心得<del>流水账</del>，暂时不知道会写多少篇，说不定两三篇，说不定一篇就变有生之年系列……</p>
<p>内容方面其实很枯燥，因为我不喜欢写一些高大上的设计思路这类的东西<del>都特么边写边删边想的哪有什么设计</del>，对于工作之外的玩意，我就喜欢写了删删了写，说好听点这叫<em>好读书，不求甚解</em>（掩面逃）。</p>
<p>哦，先丢个<a href="https://github.com/liuji-jim/raze-tpl">GitHub</a>，继续做一个不负责任的男人，无测试、无DEMO、无主页的三无项目……为了尝鲜、玩票外加装逼，我用的是TypeScript来写，其实和JS也没啥差别。</p>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个关于JavaScript解构（destructuring）语法的……呃，陷阱？]]></title>
    <link href="http://jimliu.net/2015/06/09/trap-in-es6-destructuring-syntax/"/>
    <id>http://jimliu.net/2015/06/09/trap-in-es6-destructuring-syntax/</id>
    <published>2015-06-09T10:31:35.000Z</published>
    <updated>2015-06-12T07:48:51.000Z</updated>
    <content type="html"><![CDATA[<p>没有摘要，直接看文可好？<br><a id="more"></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [a, b] = arr();</span><br><span class="line"><span class="comment">// a = 1, b = 2;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; foo: <span class="string">'bar'</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123;foo: fu&#125; = obj();</span><br><span class="line"><span class="comment">// fu = 'bar'</span></span><br></pre></td></tr></table></figure>
<p>上面是两种最基本的解构语法</p>
<p>那么看看下面的例子（来源<a href="http://weibo.com/2930876843/Ckzs5kD76" target="_blank" rel="external">@SYSU_Joyee的微博</a>）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="string">'a'</span>, [&#123; foo: <span class="string">'bar'</span> &#125;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]];</span><br><span class="line"><span class="keyword">var</span> [a, [&#123; foo: fu &#125;, , ...tail], missing, def = <span class="string">'default value'</span>] = foo;</span><br></pre></td></tr></table></figure>
<p>晕了吧，解读一下。</p>
<p>第一步，整体上，左边是一个数组解构，其中几个声明分别为<code>a, 一个数组, missing, def（带默认值）</code>。</p>
<ul>
<li><code>a</code>对应的是<code>&#39;a&#39;</code>。</li>
<li><code>一个数组</code>是一个嵌套的解构，这个下面再看。</li>
<li><code>missing</code>对应数组越界，也就是<code>undefined</code>。</li>
<li><code>def</code>对应数组越界，本来也是<code>undefined</code>，但是它带默认值了，所以应该是<code>&#39;default value&#39;</code>。</li>
</ul>
<p>上面的<code>一个数组</code>是嵌套在解构里的另一个数组解构，对它单独拆开，左边的几个声明是<code>一个对象, 抛弃, 剩余</code>。</p>
<ul>
<li><code>一个对象</code>是一个对象解构，结果是<code>fu = &#39;bar&#39;</code>。</li>
<li><code>抛弃</code>这个就不用说了，它抛弃了<code>1</code>。</li>
<li><code>剩余</code>就是剩下的<strong>数组</strong>，结果是<code>tail = [2, 3, 4, 5]</code>。</li>
</ul>
<p>so far，看起来还是比较简单的。</p>
<p>下面看一些复杂的。</p>
<p>以下例子来自<a href="http://typeof.net/2014/m/dont-invent-a-language-when-idle.html" target="_blank" rel="external">Belleve Invis的博客</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">[a.x, a.y, a.x] = [<span class="number">1</span>, (a = &#123;&#125;), <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>注意第三行的赋值语句右边也有一个赋值语句，那么执行顺序是怎样？</p>
<p>按照人类直觉的理解，上面的代码应该等价于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.x = <span class="number">1</span>;</span><br><span class="line">a.y = (a = &#123;&#125;);</span><br><span class="line">a.x = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>于是最终结果是<code>a = { x: 3 }, b = { x: 1, y: Object }</code>其中的<code>y</code>就是<code>a</code>的引用</p>
<p>然而实际结果却是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123; x: <span class="number">3</span>, y: <span class="built_in">Object</span> &#125; <span class="comment">// 其中的y就是a的引用</span></span><br><span class="line">b = &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>虽然绝大多数人这辈子也不会写这种shit一样的代码，但还是需要知道为什么会是这样。</p>
<p>因为es6的草案对解构的策略是：</p>
<ul>
<li>先分析左侧，得到一个赋值模式（AssignmentPattern）</li>
<li>计算右侧，得到一个值</li>
<li>按照左侧的模式，将右侧的值当中一部分赋值到左侧</li>
</ul>
<p>其中第三步隐含了左侧的模式可能内嵌了另一个解构，所以上述步骤是递归进行的。</p>
<p>于是乎上面的代码正确的等价应该是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"><span class="keyword">var</span> _tmp = [<span class="number">1</span>, (a = &#123;&#125;), <span class="number">3</span>];</span><br><span class="line">a.x = _tmp[<span class="number">0</span>];</span><br><span class="line">a.y = _tmp[<span class="number">1</span>];</span><br><span class="line">a.x = _tmp[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>在上述代码中，第3行将<code>a</code>赋值为了<code>{}</code>，此时<code>a</code>与<code>b</code>不再指向同一个对象。第4行中，（新的）<code>a</code>被赋值<code>a.x = 1</code>。第4行，（新的）<code>a</code>被赋值<code>a.y = a</code>，这里形成了一个循环引用的结构。第5行就不用说了，<code>a.x = 3</code>。而至始至终，<code>b</code>还是最早的那个<code>{}</code>。</p>
<p>这样的策略虽然反直觉，但细想之下不难理解。</p>
<p>首先是这样的策略非常的普适，如果左边的结构复杂，那么就会有一些分歧，比如应该按照深度优先还是广度优先来求值赋值呢？另一方面就是实现起来的话符合直觉的方式会变得更复杂一些，而现在的策略则只是需要在语法分析层面对赋值语句的语法树递归展开就行了。</p>
<p>我们把上面两段代码分别扔进<a href="https://babeljs.io" target="_blank" rel="external">babel</a>里可以得到如下的transpile结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_toArray</span>(<span class="params">arr</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(arr) ? arr : <span class="built_in">Array</span>.from(arr); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = [<span class="string">'a'</span>, [&#123; foo: <span class="string">'bar'</span> &#125;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]];</span><br><span class="line"><span class="keyword">var</span> a = foo[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _foo$<span class="number">1</span> = _toArray(foo[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fu = _foo$<span class="number">1</span>[<span class="number">0</span>].foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tail = _foo$<span class="number">1.</span>slice(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> missing = foo[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> _foo$<span class="number">3</span> = foo[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> def = _foo$<span class="number">3</span> === <span class="literal">undefined</span> ? <span class="string">'default value'</span> : _foo$<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"><span class="keyword">var</span> _ref = [<span class="number">1</span>, a = &#123;&#125;, <span class="number">3</span>];</span><br><span class="line">a.x = _ref[<span class="number">0</span>];</span><br><span class="line">a.y = _ref[<span class="number">1</span>];</span><br><span class="line">a.x = _ref[<span class="number">2</span>];</span><br><span class="line">_ref;</span><br></pre></td></tr></table></figure>
<p>可以发现babel的转译是非常遵循于es6草案的。</p>
<p>到了这里，我们应该可以安心的玩解构了，对于一些场景它会显得非常非常的有用，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[a, b] = [b, a]; <span class="comment">// swap</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hsl2rgb</span>(<span class="params">h, s, l</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> [r, g, b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [r, g, b] = hsl2rgb(h, s, l);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">negate</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">[x, y] = negate(x, y);</span><br></pre></td></tr></table></figure>
<p>在一些函数当中为了实现多返回值通常都会用返回一个数组或者KV来当元组的概念，但在接收返回值的时候却需要很麻烦的手工展开。有解构就可以更愉快的写这些代码了。</p>
<p>对于上面举例的解构在求值策略上的坑，只要注意用的姿势就OK了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>没有摘要，直接看文可好？<br>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编码歪传——番外篇]]></title>
    <link href="http://jimliu.net/2015/03/07/something-about-encoding-extra/"/>
    <id>http://jimliu.net/2015/03/07/something-about-encoding-extra/</id>
    <published>2015-03-07T13:23:12.000Z</published>
    <updated>2015-03-26T11:21:23.000Z</updated>
    <content type="html"><![CDATA[<p>我保证这是最后一篇了，而且这次的内容绝对都是很具体的，具体得连每篇博客开头例行的摘要我都不知道该写什么了！</p>
<a id="more"></a>
<h2 id="典型乱码">典型乱码</h2><h3 id="乱码、问号、方块">乱码、问号、方块</h3><p>用文本编辑器打开一个文件，如果编码不兼容，有时候会看到<code>??????</code>的东西，有时候会看到一团乱七八糟的文字，通常我们就统称乱码了。怎么用编码的知识来理解呢？</p>
<p>前文中我们有说到实用的很多编码方式都用的是变长字节编码，很多字节都要结合它的上下文去解释才是对的。例如：用UTF-8的算法去解析GBK的文件，就很容易发些这么些种情况：</p>
<ol>
<li>一个字节序列并不是合法的UTF-8字符，比如以<code>11111110</code>开头的字节序列。</li>
<li>一个字节序列碰巧符合UTF-8规则。</li>
</ol>
<p>反过来看，用GBK的算法去解析UTF-8的文件其实也差不多，遇到第一种情况在显示的时候可能就用问号代替，而遇到第二种情况就是出现一些风马牛不相及的杂乱文字。</p>
<p>方块其实和问号本质上一样的，但方块在现代浏览器里还有个很常见的情况，就是一个字符的编号在字体当中并没有定义，于是在排版和渲染的适合“智能”地用一个方块来表示它了。看到方块可以结合上下文，如果上下文当中的非英字符显示正确的，那么方块可能是一些特殊符号，比如Emoji。</p>
<p>在写服务端程序的时候要小心处理“半个字符”的问题，例如我们在前级对超长的数据进行截断处理，刚好截断掉一个变长编码的字节序列，就会出现“半个字符”。一般半个字符都是铁定会乱码，一些容错比较差的程序甚至会挂，比如一些做的不好的PHP的C扩展，严重的时候会出core。所以程序不懂编码就别瞎截，甚至考虑到某些语言文字里的组合字符，就是知道编码也别瞎截（真是细思恐极）；</p>
<h3 id="BOM">BOM</h3><p><del>BOM就是Browser Object Model浏览器对象模型，</del>不好意思拿错剧本了。</p>
<p>BOM（Byte-Order Mark，字节序标记）是Unicode码点<code>U+FEFF</code>。它被定义来放在一个UTF-16文件的开头，如果字节序列是<code>FEFF</code>那么这个文件就是大端序，如果字节序列是<code>FFFE</code>那么这个文件就是小端序。</p>
<p>UTF-8本身是没有字节序的问题的（因为它是以单个字节为最小单位），但是Windows里面很多编辑器（比如记事本）会多此一举的在UTF-8文件开头加入<code>EF BB FF</code>也就是<code>U+FEFF</code>的UTF-8编码。</p>
<p>如果你的PHP文件里面有一个这东西你就倒了大霉了，可能会：</p>
<ul>
<li>什么也看不见，可能是PHP引擎根本处理不了这个源代码。</li>
<li>页面展现错乱的情况，一般是因为在<code>&lt;doctype&gt;</code>之前输出的非空格内容造成了浏览器选择错误的doctype。</li>
<li>页面上面有及格乱七八糟的字符，浏览器把它当字符展示出来了。</li>
</ul>
<p>于是建议在Windows上做开发的同学，一定要选择“使用UTF-8无BOM格式”保存，<del>所以用记事本写代码装X就不好使了，</del>用Notepad++的可以注意选一下，它支持的文件编码格式挺丰富的，用一些比较先进的跨平台编辑器比如WebStorm、SublimeText它们都是没BOM的。</p>
<h3 id="锟斤拷">锟斤拷</h3><p>乱码之所以叫乱码，就是因为它是“乱”的。但是乱码当中最出名的就是“锟斤拷”，他出现次数太多了以至于看起来根本就没那么“乱”。这就纳了闷了，为什么全中国的网站乱码里面都会有这个？</p>
<p>原因是，在将一些国家语言编码体系，比如GB、BIG-5、EUC-JP等，转换为Unicode的过程中，多少有一些字符是不在Unicode中的（比如一些偏旁部首在Unicode里是后来才收录的），甚至它本身在原来的编码体系里面就是非法字符的情况。</p>
<p>Unicode规定了<code>U+FFFD</code>当作一个占位符用来表示这些字符，用UTF-8编码它就是<code>EF BF BD</code>，连续多个这样的字节序列出现就成了<code>EF BF BD EF BF BD</code>。如果是一个UTF-8的解析程序还好，而如果用一个GB的解析程序去打开，一个汉字2字节，就成了“锟斤拷”。<a href="/uploads/2015/kunjinkao.txt">这里</a>就是一个例子，用UTF-8编码打开是问号，用GBK编码打开的话就会看到锟斤拷，用hexdump或者UltraEdit这类任何16进制编辑器看的话就能看到里面都是<code>EF BF BD</code>。</p>
<p>要避免锟斤拷一个重要的点就是尽量减少程序当中的编码转换。比如输入是UTF-8，但是一个旧的模块是GBK，把UTF-8转成GBK交给旧的模块处理，处理过程中旧模块多多少少有些BUG的可能，再转回来的时候就容易锟斤拷了。一个项目的源代码在团队里面被不同的人（他们编辑器配置不尽相同）开来开去，存来存去，也很容易出现锟斤拷。</p>
<h3 id="烫烫烫、屯屯屯">烫烫烫、屯屯屯</h3><p>这个和编码转换其实没啥关系，在VC的DEBUG模式下，会把未初始化的栈内存全部填成<code>0xCC</code>，未初始化的堆内存填成<code>0xCD</code>，这样做是让你一眼就能看出来你开了内存没初始化。</p>
<p>而用GBK编码的话，<code>CC CC</code>就是“烫”，<code>CD CD</code>就是“屯”。</p>
<h2 id="URL_Encode和Base64">URL Encode和Base64</h2><h3 id="URL_Encode">URL Encode</h3><p>URL Encode又称为“百分号编码”它主要用来在URI里面将特殊字符进行转义，因为像<code>/</code>、<code>&amp;</code>、<code>=</code>等等这类字符在URI里面本身是有功能性的。</p>
<p>对于ASCII字符的编码很简单就是用<code>%</code>后跟ASCII编码的16进制表示，例如<code>/</code>的ASCII char code是<code>47</code>，16进制表示是<code>2F</code>，于是它的URL Encode结果就是<code>%2F</code>。</p>
<p>对于非ASCII字符，将它的每个字节进行相同规则的转换，例如中文“编码”的Unicode char code是<code>U+7F16 7801</code>，UTF-8编码的字节序列是<code>E7 BC 96 E7 A0 81</code>，所以它按照UTF-8编码的URL Encode结果就是<code>%E7%BC%96%E7%A0%81</code>。</p>
<p>可以看出，URL Encode编码非ASCII字符的时候，结果与使用的字符编码有关。因此在页面上提交表单、发起Ajax请求等操作的时候需要注意编码。浏览器会按照当前页面所使用的字符编码对表单体提交进行URL Encode，但使用JavaScript的<code>encodeURI</code>和<code>encodeURIComponent</code>的时候则总是会使用UTF-8（<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent" target="_blank" rel="external">参考MDN</a>）。</p>
<p>表单提交的时候编码是非常非常重要的，一旦错了服务端解开数据的时候就会跪。比如Github在它们的搜索表单里面放了一个<code>&lt;input name=&quot;utf8&quot; type=&quot;hidden&quot; value=&quot;✓&quot;&gt;</code>，其中那个对钩&#x2713;是<code>U+2713</code>，UTF-8编码是<code>E2 9C 93</code>，他们可以在服务端检测这个参数的值对不对从而对URL里用的编码进行一个初步检测。虽然我没有看到他们使用其他编码的情况，不过这样也算是一个编码协商和Check的手段吧。</p>
<p>在JavaScript中使用<code>escape</code>也可以达到URL Encode的效果，但是它对于非ASCII字符使用了一种非标准的的实现，例如“编码”会被<code>escape</code>成<code>%u7F16%u7801</code>这种<code>%uxxxx</code>奇怪的表示，W3C把这个函数废弃了，身为一名前端还用是打脸的哦。</p>
<h3 id="Base64">Base64</h3><p>Base64是一种<strong>用可见字符表示二进制数据</strong>的方法。它用了64个可见字符<code>[A-Za-z0-9+/]</code>。</p>
<p>Base64的编码程序非常简单，由于64=2^6，6和8的最小公倍数是24，也就是3byte，因此对输入数据以3byte为一个单位，查表把它转换成4个可见字符。</p>
<p>如果输入末尾不足3byte，那就补足，补1个byte就在输出末尾添加一个<code>=</code>，补2个byte同理。</p>
<p>Base64经常用来在一些文本协议里面保存二进制数据，比如HTTP协议，或者电子邮件的附件啊什么的。同时因为它的输出对于人类而言不可读，可以起到一些“混淆加密”的作用，事实上就有修改64个字符的排布来做一个变形Base64实现一个简单加密算法的例子。从密码学的角度看它基本上没什么强度可言，但是足够简单，可以起到防君子不防小人的作用。</p>
<p>由于一个字符只能编码6bit，自身却占了8bit，8/6=1.33，因此使用Base64来表示数据的时候会浪费1/3的体积。对于在CSS里面用Base64的data-url方式表示图片，用之前不妨简单估算一下，膨胀的体积和一个HTTP请求头比起来会相差多少，说不定涨太多了已经损失掉省一个请求的收益了。</p>
<h2 id="尾声">尾声</h2><p>终于整个系列都要结束了，理论的也好，实用的也好，基本上我觉得该说的都说了，要是以后再遇到乱码，一定会很快知道问题所在。</p>
<p>最后还是要佩服并感谢一下ISO和Unicode联盟，做了这么伟大的事情将全世界的语言文字统一收录和编码，而这当中包括了那么多我们根本没听说过的奇怪的语言文字。正是因为他们的努力奠定了互联网是一个无国界的世界，每天我们都能通过它获得来自任何地方任何语言的信息。</p>
<p>哦，我上面说的不是某国的互联网。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我保证这是最后一篇了，而且这次的内容绝对都是很具体的，具体得连每篇博客开头例行的摘要我都不知道该写什么了！</p>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编码歪传——Web篇]]></title>
    <link href="http://jimliu.net/2015/03/07/something-about-encoding-web/"/>
    <id>http://jimliu.net/2015/03/07/something-about-encoding-web/</id>
    <published>2015-03-07T03:23:12.000Z</published>
    <updated>2015-03-26T11:21:23.000Z</updated>
    <content type="html"><![CDATA[<p>继续上一篇。</p>
<p>身为一名Web开发者，这一篇将介绍一下在Web应用当中常会出现编码问题的地方。文中经常会乱用“字符集”和“编码”，不过看明白了第一篇的话相信你不会混淆概念，而且我个人觉得这两个概念很多时候混淆也无妨……</p>
<a id="more"></a>
<h2 id="概念">概念</h2><p>出于把问题描述得稍微清楚一点的目的，我打算先把我们的概念进行一下定义。</p>
<p>一般而言我们常遇到乱码的场景有这样两种：</p>
<ol>
<li>作为写入端，我应该用什么编码来<strong>存储</strong>/<strong>传输</strong>？</li>
<li>作为读出端，我应该用什么编码来<strong>消费</strong>我所收到的字节流？</li>
</ol>
<p>因为我觉得绝大多数具体场景都可以归纳成上述两种，所以这样应该可以简化一下问题。</p>
<h2 id="程序内部处理">程序内部处理</h2><p>现代编程语言一般都内建<strong>字符串</strong>作为自带的数据类型，一门强大且又实用的编程语言通常来说都有高效的字符串实现以及大量配套的字符串处理函数。</p>
<p>在上一篇中我们有顺带提到，<strong>UTF-16</strong>因为是一种在处理效率和存储空间之间比较平衡的，同时编码空间又足够大的编码方式，在一些编程语言当中被采用来当作字符串的内部编码。比如C#、Java（可能因JVM/JDK而异）。</p>
<p>一般而言编程的String类型编码都是固定的，但是通常会提供丰富的编码转换函数。一种（我认为）比较可靠的方式是：String用固定编码方式实现，以使得标准的字符串函数能够只关注一种编码，从而保证它的正确性，也能够最大程度地针对性优化；而通过使用类库来将String转换为特定编码的字节流，或将字节流以特定编码转换成String。</p>
<p>反过来看，像PHP里的字符串就比较糙，它的编码有很大问题，如果一个字符串是多字节的（通过上一篇我们了解到除了ASCII以外基本上常用的编码都是多字节的），处理它就要用mb_xxxx系列的函数。这对编程是一种负担，因为这样就意味着String类型对字符的抽象力度不足，还是得花很多精力去关注字符串的编码。对于PHP的程序一个办法就是在整个程序内部统一编码，同时基于此选择好使用那一组字符串处理函数（作为项目规范），避免程序内部关心编码的问题，只把编码暴露在与外界交换数据的地方。</p>
<h2 id="存储/传输">存储/传输</h2><p>管你是什么程序，程序所生成的东西总要被消费才有意义（不然就变成烤机程序了）。Web应用里最常见的两种对程序结果的消费方式，一是把它存储（数据库、文件）起来，二是把它传输给用户（浏览器）以供展现。</p>
<p>当需要存储/传输文本的时候，就需要高度关心字符编码了。</p>
<h3 id="存储">存储</h3><p>很多人遇到的问题是把用户表单提交的东西写进MySQL里面以后乱码了，这个问题一些可能的原因有：</p>
<ol>
<li>提交内容的字符编码</li>
<li>服务端程序（如PHP）内部使用的编码</li>
<li>MySQL传输时候使用的编码</li>
<li>MySQL数据库声明和使用的字符集</li>
</ol>
<p>第1点下一步会更详细的展开。</p>
<p>第2点在上文当中有一定介绍了，PHP程序所接收的字节流被当作字符串看待后，我们的程序必须要选择合适的字符串处理函数，结果才会是对的。比如一个截断程序要能正确处理多字节编码，如果把多字节编码切断成“半个字符”严重的时候甚至会造成PHP出core。</p>
<p>第3点就是PHP中常见的<code>mysqli_set_charset</code>所覆盖的范围，没错，因为MySQL其实是服务，所以这个存储其实也是传输。</p>
<p>第4点就是在建库建表的时候选的那个字符集和编码。</p>
<p>这当中的重点的就是2需要对1的编码有预期，正确的把1的字节流解析出来，转换成程序内部字符串实现所使用的编码，套用正确的算法，接下来与MySQL驱动和服务之间使用双方预期的编码，最终以数据库定义的时候所声明的字符集保存下来。</p>
<h3 id="传输">传输</h3><p>一个HTTP请求发出的时候，用户代理（UserAgent，通常是浏览器）可以通过HTTP Request Header中的<code>Accept-Charset</code>字段来显式声明预期返回的编码，这是一种协商手段。现在的浏览器都很流弊，啥编码都能解析，于是直接懒得发这个，言下之意就是服务端给返回什么就消化什么。</p>
<p>对于服务端而言，如果收到的请求指定了<code>Accept-Charset</code>那么应该按照请求者的预期来决定响应内容的编码，如果没有指定，则可以“自由发挥”，这种时候理论上说你用什么编码都可以，但最终都必须通过某种手段告诉请求者响应内容是什么编码。</p>
<p>方式1：使用HTTP Response Header中<code>Content-Type</code>来给响应内容声明编码。比如<code>Content-Type: text/html; charset=UTF-8</code>。这里有个小插曲，在IE6（没记错的话）里用Ajax请求的时候如果Response写的是小写<code>utf-8</code>就会跪，必须要大写。<del>别问我为什么知道，说起来都是泪，那是一个风雨交加的深夜……</del></p>
<p>方式2：通过HTML页面头部的<code>&lt;meta charset=&quot;xxx&quot;&gt;</code>标签来给页面声明编码。如果Response Header里不写编码，浏览器就会尝试找这个标签，然后将接下来的内容以这个编码解读。这就是为什么我们提倡将<code>&lt;meta charset=&quot;xxx&quot;&gt;</code>写在<code>&lt;title&gt;</code>标签之前的原因，如果<code>&lt;title&gt;</code>出现在此之前，它里面的字符就不知道该用什么编码来解读了，直观的说就是可能造成title乱码。</p>
<p>一旦决定了编码，服务端程序就会将字符以该种编码最终写入字节流，传给客户端。</p>
<p>那如果两种方式都用了，口径却不一致会怎么办？首先当然是给开发者赏两耳光，然后有兴趣的可以做做实验看看不同的浏览器会有什么不同的兼容策略。</p>
<h3 id="用户提交内容">用户提交内容</h3><p>上面有说表单提交也有个编码的问题，其实包括Ajax请求等，只要是客户端向服务端发送内容，都一样，但通过上面的例子我想你已经明白了，这完全是镜像的，这次浏览器扮演着信息的生产者的角色，本质是完全一样的。</p>
<h2 id="消费">消费</h2><p>给你一本书，你怎么知道它是中文版还是英文版？“我靠，它用英文写的就是英文版，用中文写的就是中文版啊。”</p>
<p>人类的大脑简直聪明得要命了，这种问题根本不需要动脑子，计算机就要笨多了。其实并不是计算机笨，而是这个问题在计算机的领域里面太难了。比如上一篇文章说到GB2312是兼容ASCII的，那么如果收到的内容前几个字节是<code>3C 68 74 6D 6C 3E</code>也就是<code>&lt;html&gt;</code>的ASCII编码，也许臆想它是ASCII的，于是后面出现的双字节字符可能就会遭殃了。UTF-8有一个很不错的性质是它比较容易识别，但是也有错误率和效率问题。<del>所以这些你猜来我猜去的不靠谱的倒霉事情就只让它出现在男女情爱当中吧不要来污染我们纯净的计算机世界了好吗。</del></p>
<p>上面一节当中有说到，一个靠谱的信息生产者，会在给你传递信息的时候协商或声明编码。身为一个合格的信息消费者，浏览器可以通过这些声明来选择正确的编码，解读字节流。</p>
<p>浏览器也是个程序，于是它内部也会有字符串实现，也许它用自带字符串的语言实现的，也许它用自己实现的字符串（如C/C++），不管怎样，有了明确的编码，浏览器都能够将所获得的字节流转换成自己所使用的内部编码。</p>
<p>事已至此，似乎只要生产者靠谱，消费者要注意的问题就非常少了。在服务端我们小心翼翼地处理那么多环节的编码问题，到了浏览器好像已经完事儿了。不管这之前有再多波折，浏览器内部各种对字符的处理再多，基本上都不会有编码的问题了，简直太没劲了，于是这里稍微发散思维一下。</p>
<p>接下来浏览器就需要把字符显示出来，我们考虑浏览器通过操作系统给它提供的API。API要么规定编码要么协商/声明编码对吧，如果是前者，浏览器需要把自己内部用的编码转换成API所预期的编码，然后调用API——在这个场景里面，浏览器又从信息的消费者变成生产者了对吧，而这次操作系统是消费者。</p>
<p>然后我们假设操作系统将会用某种字体渲染这段字符，字体文件内部一般都对每个字符进行编号，现代的字体一般都会用Unicode，没错，我们又回到了字符集的概念。操作系统将字符编码还原到字符集当中的字符编号（显然对于变长字节编码这个过程要一些运算），在字体文件内通过编号查到这个字符，一个设计良好的字体可能对同一个字符会设计了多个<strong>字形</strong>（Glyph），比如Regular体一个、粗体一个、斜体一个，甚至还有更多更多，比如组合字符、一些特殊规则下的变形字符，不展开讨论。</p>
<p>这些渲染规格都是在API里指定好的，然后就用对应的字形来进行渲染。渲染字形这事儿还不是一个简单的事情，字体分点阵的、矢量的（甚至图片的？），不同的渲染引擎，例如Windows上的GDI、DirectWrite、第三方的GDI++、MacType，还有OSX的渲染引擎，Linux不同的桌面系统的渲染引擎，在最终把字形绘制成像素点的算法上有细节区别。</p>
<p>上面说的还只是渲染单个字符的时候的问题，在此之前还要做文字的排版啊什么的，哪怕看起来很小一件事情也够人钻大半辈子了。我的天，人类为了在计算机上展示文字到底下了多少功夫？</p>
<p>好的好的，刚才似乎发散的太多了，就此打住，总之就浏览器而言对于一个HTML页面的消费差不多是可以理解了。</p>
<h2 id="阶段性小结">阶段性小结</h2><p>把乱码的问题从一个信息的生产者和消费者两个角度来看，中间所经历的哪些环节涉及到编码，哪些环节涉及到编码的协商与声明，就明确多了。上面的例子其实很容易就可以举一反三。</p>
<p>于是一些常见的诸如“PHPMyAdmin里看是正常的，页面上是乱码”或者“页面上是正常的，PHPMyAdmin里看着是乱码”这种问题可能会是哪些个环节闯的祸心里就已经有谱了。对于各种接口，比如与MySQL通讯，比如与后端之间的接口，如何协商/声明编码，什么时候需要转换编码，心里面也有谱了。</p>
<h2 id="预报">预报</h2><p>呵呵呵呵，这次的内容虽然没那么理论，但是还是太简单了嘛，看到乱码就查编码呗你当我是傻X呢。</p>
<p>这时候也有观众吐槽：“那么各种程序当中用的编码比如URL Encode、Base64又是些啥玩意啊老湿？”</p>
<p>也有好奇心过盛的观众要问：“问号和方块是怎么回事？屯屯屯烫烫烫锟斤拷又是些什么鬼呢老湿？”</p>
<p>对于上面的问题我只想说四个字：<del>请联系我</del>请看终篇：<a href="/2015/03/07/something-about-encoding-extra/">《编码歪传——番外篇》</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续上一篇。</p>
<p>身为一名Web开发者，这一篇将介绍一下在Web应用当中常会出现编码问题的地方。文中经常会乱用“字符集”和“编码”，不过看明白了第一篇的话相信你不会混淆概念，而且我个人觉得这两个概念很多时候混淆也无妨……</p>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编码歪传——基础篇]]></title>
    <link href="http://jimliu.net/2015/03/06/something-about-encoding-basic/"/>
    <id>http://jimliu.net/2015/03/06/something-about-encoding-basic/</id>
    <published>2015-03-06T12:23:12.000Z</published>
    <updated>2015-03-26T11:21:23.000Z</updated>
    <content type="html"><![CDATA[<p>子曰：乱码是一种思念，而思念是一种病。相信很多Web人常常纠结于乱码当中，可能是展现、可能是表单提交、可能是数据库、可能是接口、可能是抓取……反正任何一个涉及到输入或者输出字符的地方都有可能被你碰到过乱码。</p>
<p>为了解释和解决乱码问题，并且明确一些常见的误区，我打算写这样一个系列，介绍一些字符编码相关的东西，目前规划了3篇。</p>
<p>基本上内容会比较偏科普性质，希望大神们轻拍，因为我相信这些将会是非常重要的基础知识，如果你能完整的读下去，肯定会在你以后遇到乱码的时候帮助到你的思考方式，快速找到原因。</p>
<a id="more"></a>
<h2 id="字符">字符</h2><p>我们的语言基本上都围绕着<strong>字符</strong>，就是<strong>character</strong>，常简称<strong>char</strong>，很多时候字符会是文本的最小组成单位（注意只是“很多时候”，因为世界是奇妙的）。</p>
<p>不是一定要文字才叫字符，一些注音字符、数学符号、某些文字里的修饰符号、特殊符号、表格符号、甚至Emoji等等，其实都是字符。</p>
<h2 id="字符集">字符集</h2><p>字符要成套才有用，比如“英文字母”就是一个字符集，当然这么说听起来对计算机毫无意义。</p>
<p>一般我们所说的<strong>字符集</strong>（Character Set）就是一个规范，它收录若干字符，并且给这些字符逐一分配了一个<strong>编号</strong>当作索引（为了不过早引入<strong>编码</strong>的概念造成混淆，这里我称其为“编号”）。</p>
<h3 id="ASCII">ASCII</h3><p>ASCII是当今计算机世界最经典的字符集，它收录了英文字母和若干标点，还有一些专门供计算机使用（不是给人看）的控制字符。</p>
<h3 id="GB系列">GB系列</h3><p><strong>GB2312</strong>是一个常见的中文字符集，其中“GB”就是“国标”（咱们国家很多不同行业的标准代号都是这样命名的）。它收录了大概几千个汉字，以及几百个西文字符。</p>
<p><strong>GBK</strong>是微软最早在Win95里实现的对GB2312进行的扩展，追加了很多繁体字和西文字符，总计收录的字符数大概有20000多个。K就是拼音“扩展”。</p>
<p><strong>GB18030</strong>是国标对GB2312的升级（当然中间还有其他升级，但大多被淹没在历史潮流里面了），它一下就收录了70000多个字符，最大的升级部分有繁体中文字符、新字、生僻字、少数民族文字、日韩字符等。</p>
<p>上面三个GB系列的字符集都是为中文设计的，当然也扩充了一些东亚语文的内容（CJK字符，Chinese, Japanese, Korean），因为这些邻居的字符在中国也挺常出现的。</p>
<h3 id="Big5">Big5</h3><p>又称大五码，是繁体中文地区，例如湾湾、港港、澳澳常用的字符集，大概收录了一万多个字符，其中以繁体中文为主。因为被Windows所接受成为繁中版的默认编码而成为了事实标准。</p>
<h3 id="UCS">UCS</h3><p>就像中文一样，几乎每种语言都存在一个给自己的语言设计字符集的问题。</p>
<p>ISO意识到这个问题之后，设计了一套<strong>通用字符集UCS</strong>（Universal Character Set），目的是用一套字符集表示全世界（甚至外星人！？）的所有字符！</p>
<p>结果UCS成功了，因为互联网发展的太快了，任何国家的人每天都在互联网上浏览来自全世界的不同语言不同文字的内容，大家当然希望用一套字符集就能收录全世界所有的字符。</p>
<h2 id="字符编码">字符编码</h2><p>很多人会把<strong>字符集</strong>和<strong>字符编码</strong>的概念搞混，其实不怪，因为这俩东西好多时候都是捆绑定义的。</p>
<p><strong>字符编码</strong>（Character Encoding）就是按照一定的技术要求（比如以8bit为单位）对字符集中的每一个字符进行编码，以便文本能够在计算机和网络传输上使用。</p>
<p>简单的说，就是把字符集里面的那个每个字符的编号，给弄成计算机能懂的格式。</p>
<p>很多字符集在制定的时候，就已经配套了它的编码方案，比如ASCII、GB系列、Big5。对于这种字符集/编码，称呼上虽然模糊，但结合技术语境而言一般也不会有什么误解。</p>
<h3 id="ASCII-1">ASCII</h3><p>标准ASCII只收录了128个字符，使用7bit可以完美编码。例如英文字母<code>A</code>的ASCII编码就是十六进制<code>0x41</code>，然后1字节剩下的一位就没啥用了，可以用来当奇偶校验。</p>
<p>后来ASCII被扩展到了8bit，供256个字符，用8bit也就是1字节可以完美编码，并且低7字节完全兼容。</p>
<p>ASCII是国际标准而扩展ASCII并不是，下文所说到的“兼容ASCII”都是指兼容7bit的标准ASCII。</p>
<h3 id="GB2312">GB2312</h3><p>GB2312使用1/2字节变长编码，单字节部分是兼容ASCII，其他几千个字符都是用双字节编码。</p>
<p>GB2312在编码的时候使用了一个“分区”的概念，小时候家里有一本区位码表，就是配合Windows里古老的“区位输入法”用的。</p>
<h3 id="GBK">GBK</h3><p>GBK的编码方案是GB2312的超集，它完全兼容GB2312，不过把GB2312里面没定义的那些编码空间都用起来了。</p>
<h3 id="GB18030">GB18030</h3><p>GB18030的编码方案稍微复杂一点，它用的是1/2/4字节变长编码方案。它完全兼容GB2312，基本上兼容GBK。</p>
<h3 id="Big5-1">Big5</h3><p>Big5使用固定两字节编码，它的首字节避开了ASCII的范围，因此实际在程序实现上面它可以近似兼容ASCII，由于它的低字节包含了一些ASCII字符，这个兼容也是不完美的，具体情况可以看看维基百科，非常有趣。</p>
<h3 id="Unicode">Unicode</h3><p>Unicode有一个非常高大上的中文名字叫万国码<del>，呵呵，这个名字真是散发着一股农业重金属的气息啊</del>。其实也是个字符集，它和UCS之间有微妙的高度雷同关系，好在两边的组织都意识到了搞分化是不好的，于是互相之间达成了高度的一致。虽然它们的确是两个不同的标准，但很多时候混淆来看也无妨。</p>
<p>Unicode是定长编码，根据版本不同，它有2字节（对应UCS-2）、4字节（对应UCS-4）的版本。</p>
<p>因为Unicode是定长的，它实在太简单粗暴了。例如如果用4字节的Unicode来传输英文文本就浪费了3倍的体积，而用2字节的版本也不爽，一来容量较小，二来对于英文文本也还是浪费的。于是在实现上对它进行了一定的优化，称为<strong>Unicode转换格式（Unicode Transformation Format）</strong>也就是我们耳熟能详的<strong>UTF</strong>了。</p>
<h4 id="UTF-32">UTF-32</h4><p>UTF-32是UCS-4的最朴素的实现方式，就是简单地用定长4字节。</p>
<p>缺点嘛很明显就是很浪费体积。</p>
<p>优点也是有的，首先就是把它转换到Unicode最简单，而且对于“第[i]个字符”这种随机访问也很好计算，直接<code>字节数/4</code>就是了对不？</p>
<p>但因为组合字符（比如越南语，网上用来搞一个超长的流泪图标破坏排版那种）的存在，一个UTF-32码元（4字节）严格上也并非一个文本编辑上的单元，这种情况下对于排版系统而言UTF-32没有太多优势。</p>
<h4 id="UTF-16">UTF-16</h4><p>UTF-16是使用2/4字节实现的UCS-4变长编码。</p>
<p>因为大多数时候用到的字符不超过65536个，所以UTF-16在大多数时候1个字符都只占2字节，这样比起UTF-32省了接近一半体积，同时它的解析也不会太麻烦。</p>
<p>固定长的编码方式对于计算机程序而言有一个非常大的优势就是字符串处理会容易的多，尤其是正则表达式的实现。因此很多现代语言，例如C#/Java的字符串内部实现使用UTF-16，因为它是一种效率和体积比较平衡的编码方式。</p>
<h4 id="UTF-8">UTF-8</h4><p>UTF-8应该是现在互联网上使用最广泛的统一语言编码实现方式了。</p>
<p>它是1-4字节变长编码（原本是1-6字节，但是因为后面那些超出了Unicode定义了，后来就改成1-4字节了）。单字节的情况兼容ASCII，在这个由英文主宰的互联网环境里面这是非常好的特性，因为它在很多时候会非常节省体积，而且这种时候完全不需要编码转换。</p>
<p>但它的缺点也相当明显，将UTF-8转换到Unicode的算法会更加复杂，效率降低。</p>
<p>对于中文环境而言UTF-8也比较吃亏，因为使用UTF-8编码大多数中文字符需要3字节，这就比GB系列和UTF-16浪费空间。</p>
<p>UTF-8并未编码0x10FFFF以上的部分，所以严格的说它只是UCS-4的子集。好在缺失的那部分本身就不受UCS/Unicode的重视，估计实在是太犄角旮旯了。</p>
<p>我觉得UTF-8最终成为互联网主流很大一定程度是因为它的单字节是兼容ASCII的。</p>
<h2 id="阶段性小结">阶段性小结</h2><h3 id="字符集-1">字符集</h3><p>收录了很多字符，并且编号，给人看的。</p>
<h3 id="编码">编码</h3><p>实现一个字符集，将它的编号以一定规则用二进制实现，给计算机看的。</p>
<h3 id="GB系列-1">GB系列</h3><p>中国的国标字符集/编码，GB2312和GBK已经基本上过时了，如果要良好的支持中日韩文，又逃不开GBK的魔爪（比如历史代码束缚），那可以考虑升级到GB18030，这是国标的最新版，也是最先进的一版。</p>
<h3 id="UCS/Unicode">UCS/Unicode</h3><p>把全世界上百万个你见过的或者你没见过的字符全部收录进一套字符集，已经被全世界接受成为了国际标准。</p>
<h3 id="UTF">UTF</h3><p>UCS/Unicode转换格式，就是实用的编码方案，用于计算机实现。</p>
<h3 id="UTF-16-1">UTF-16</h3><p>UCS/Unicode的一种折衷了处理效率和存储空间的编码实现方案，常被各种现代语言当作字符串内部编码使用。</p>
<h3 id="UTF-8-1">UTF-8</h3><p>UCS/Unicode的一种倾向于节省空间的编码实现方案，因为对ASCII兼容，对英文文本非常有利，成为了当今互联网的主流（甚至事实标准）。</p>
<p><strong>如果你的网站没有任何历史包袱，直接上UTF-8别商量！</strong></p>
<p><strong>如果你的网站有一些历史包袱，商量商量还是上UTF-8吧，包袱的接口上转换一下编码。</strong></p>
<h2 id="预报">预报</h2><p>呵呵呵呵，虽然文章的标题叫做《编码歪传》，但其实上面的内容一点也不歪嘛。</p>
<p>有观众看不下去了：“拜托，你讲这些什么乱七八糟的理论知识我没啥兴趣啊，我想知道的其实只是为什么我的网页会乱码啊老湿！”</p>
<p>对于上面的问题我只想说四个字：<del>请联系我</del>请看下集：<a href="/2015/03/07/something-about-encoding-web/">《编码歪传——Web篇》</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>子曰：乱码是一种思念，而思念是一种病。相信很多Web人常常纠结于乱码当中，可能是展现、可能是表单提交、可能是数据库、可能是接口、可能是抓取……反正任何一个涉及到输入或者输出字符的地方都有可能被你碰到过乱码。</p>
<p>为了解释和解决乱码问题，并且明确一些常见的误区，我打算写这样一个系列，介绍一些字符编码相关的东西，目前规划了3篇。</p>
<p>基本上内容会比较偏科普性质，希望大神们轻拍，因为我相信这些将会是非常重要的基础知识，如果你能完整的读下去，肯定会在你以后遇到乱码的时候帮助到你的思考方式，快速找到原因。</p>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个伪前端的Go入门——面向对象编程篇]]></title>
    <link href="http://jimliu.net/2015/02/07/beginning-go-oop/"/>
    <id>http://jimliu.net/2015/02/07/beginning-go-oop/</id>
    <published>2015-02-07T09:42:34.000Z</published>
    <updated>2015-03-26T11:21:23.000Z</updated>
    <content type="html"><![CDATA[<p>伟大领袖毛主席说，烂尾是不好的。虽然学习Go对我而言多半是玩票性质的，但是既然坑已经挖了就还是先安心填吧，反正快过年了，年前尽量就不要留遗憾了嘛对不对。</p>
<p>这一篇将主要介绍Go当中的类型系统和面向对象编程实现。</p>
<a id="more"></a>
<p>任何面向对象（或近似于面向对象）编程语言，只要理解了它的类型系统，基本上它的面向对象方法论就能闹明白了。</p>
<h2 id="基础概念">基础概念</h2><p>一个典型的面向对象语言的类型系统通常都会包含以下几个概念：</p>
<ul>
<li>基础数据类型：如整数、浮点数、布尔、字符串等</li>
<li>复杂数据类型：如数组、struct/class、指针等</li>
<li>“万物之源”类型：如Java/C#里面的<code>Object</code>类型</li>
</ul>
<h2 id="类型约束">类型约束</h2><p>以上概念只是对类型本身的分类，而在对类型的约束方面，可体现出一门语言的面向对象方法论。例如：</p>
<p>C++中没有“万物之源”类型，也没有接口。在函数签名中指定class是它主要的类型约束方式，使用template进行元编程可以当一点duck typing来看（不严谨）。</p>
<p>C#和Java中的“万物之源”类型是<code>Object</code>，这一点上C#更彻底，因为它的基础数据类型也继承<code>Object</code>而在Java里则不是。C#和Java都有interface，使用class/interface是最常见的类型约束方式。除了在函数签名中约束，C#强大的泛型编程还支持在定义泛型类型的时候约束。</p>
<p>JavaScript中有一个看起来很像“万物皆为对象”类型的<code>Object</code>，但其实它并不是所有类型的源头，这并不是很严谨。JS反正运行时访问不存在的字段就报错，这带来了不少工程化上的劣势，但是确实也增加了很多编程的灵活性。毕竟动态语言和静态语言的思路还是不一样的。</p>
<p>由于实际生产中的JS常常会用类似<code>if (typeof obj.method === &#39;function&#39;)</code>来判断一个对象是否包含某个方法/字段，我们可以不严谨地认为JS的类型约束一方面是靠君子协议，一方面是靠“运行时手工duck typing”。</p>
<h2 id="Go中的结构体">Go中的结构体</h2><p>基础数据类型和复杂数据类型在前作中已经介绍过了，这里就不多唠叨了。</p>
<p>Go没有class只有struct，不过其struct上也可以定义方法，但看起来很不一样。C++/C#/Java都是在定义一个class的时候就给它定义方法，直观的感受就是成员方法都会在<code>class XXX {}</code>的那一对大括号里面。而Go中struct的成员方法则都是“后来”添加上去的。例如</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个<span class="keyword">Person</span>类型</span><br><span class="line">type <span class="keyword">Person</span> struct &#123;</span><br><span class="line">  Name  string</span><br><span class="line">  Age int</span><br><span class="line">&#125;</span><br><span class="line">// 为<span class="keyword">Person</span>类型添加一个成员方法introduce</span><br><span class="line">func (this <span class="keyword">Person</span>) Introduce() &#123;</span><br><span class="line">  fmt.Println(<span class="string">"My name is"</span>, this.Name, <span class="string">"and I'm"</span>, this.Age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就是给现有类型添加成员方法的办法，参数里虽然叫<code>this</code>但其实只是图这个名字比较熟悉而已，并不是固定的。</p>
<h2 id="继承">继承</h2><p>Go里没有继承，它用了一种称为“匿名组合”的方式来满足对继承的需要，大概可以理解为<code>Mixin</code>吧。例如</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个Coder类型，让它“继承”<span class="keyword">Person</span></span><br><span class="line">type Coder struct &#123;</span><br><span class="line">  <span class="keyword">Person</span></span><br><span class="line">  APM float32</span><br><span class="line">&#125;</span><br><span class="line">// 为Coder类型添加成员方法coding</span><br><span class="line">func (this Coder) Coding() &#123;</span><br><span class="line">  if this.APM &lt; 100 &#123;</span><br><span class="line">    fmt.Println(this.<span class="keyword">Person</span>.Name, <span class="string">"is coding slowly"</span>);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    fmt.Println(this.<span class="keyword">Person</span>.Name, <span class="string">"is coding fast"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">jim := Coder&#123;<span class="keyword">Person</span>&#123;<span class="string">"Jim Liu"</span>, 18&#125;, 300&#125;;</span><br><span class="line">jim.Introduce();</span><br><span class="line">jim.Coding();</span><br></pre></td></tr></table></figure>
<p>这样就让<code>Coder</code>“继承”了<code>Person</code>。</p>
<h2 id="接口">接口</h2><p>在C#和Java中定义接口，可以用来进行进行类型约束，接口实现表达的是<code>can-do</code>语义，比类型继承的<code>is-a</code>语义更加灵活。</p>
<p>Go里也使用接口<code>interface</code>来约束类型，不过比C#和Java里的要灵活一些。</p>
<h3 id="定义接口">定义接口</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">type</span> <span class="type">IGreetable</span> interface <span class="container">&#123;</span><br><span class="line">  <span class="type">Greeting</span>(<span class="title">name</span> <span class="title">string</span>)</span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>很简单就是写上函数签名。接口可以组合，就像对<code>struct</code>进行匿名组合一样，对<code>interface</code>也可以进行匿名组合。</p>
<h3 id="实现接口">实现接口</h3><p>C#/Java中一个类型要实现一个接口，需要在声明类型的时候连带声明它实现了哪些接口，然后挨个实现接口所声明的方法，否则编译器会无情拒绝。</p>
<p>上面说到由于Go的成员方法是在<code>struct</code>定义之后才添加上去的，那么一个<code>struct</code>怎么才算实现一个接口呢？Go用了一种我个人称它叫“编译时duck typing”的约束，就是说一个<code>struct</code>只要它拥有的成员函数满足一个<code>interface</code>的定义，那它就可以满足该接口的约束，例如：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (this <span class="keyword">Person</span>) Greeting(name string) &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Hello"</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就让<code>Person</code>实现了<code>IGreetable</code>接口，可以<code>var gre IGreetable = Coder{Person{&quot;Jim Liu&quot;, 18}, 300};</code>了。</p>
<p>Go中的“万物之源”类型就是空接口<code>interface{}</code>，这个……在网上基本对它都是贬义，因为它就像C/C++里面的<code>void*</code>一样泛滥。</p>
<h2 id="泛型">泛型</h2><p>为什么<code>interface{}</code>会泛滥？因为Go没有泛型。我了个去，作为一门现代静态语言竟然没有泛型？没有泛型的情况下，<code>interface{}</code>就很容易满天飞。</p>
<p>与此同时，安全的类型转换也是有必要的，在C#中做安全类型转换可以这么做：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ICodable coder = <span class="keyword">person</span> as ICodable;</span><br><span class="line">if (coder != null) &#123;</span><br><span class="line">  coder.Coding();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go搞了一个叫“接口查询”的东西，跟上面比较像</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func tryCoding(<span class="keyword">person</span> IGreetable) &#123;</span><br><span class="line">  if coder, ok := <span class="keyword">person</span>.(ICodable); ok &#123;</span><br><span class="line">    coder.Coding();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Oops, not a coder."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码里那个<code>person.(ICodable)</code>就是一个“接口查询”，这个嘛我觉得倒是挺恶心的。</p>
<h2 id="小结">小结</h2><p>Go虽然没有常见的class、继承、虚函数等概念，但是通过匿名组合大概实现了继承和虚函数的效果。</p>
<p>Go的接口是先定义后实现的，这样一旦定义了一个新接口，只要它的签名和某些已有类型能match上，那么旧类型也可以当新接口实例来用，比较灵活。</p>
<p>Go没有泛型，少了一种现代静态语言的元编程和类型约束的利器，真是啧啧啧，这个实在不应该，不知道以后打不打算引入。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>伟大领袖毛主席说，烂尾是不好的。虽然学习Go对我而言多半是玩票性质的，但是既然坑已经挖了就还是先安心填吧，反正快过年了，年前尽量就不要留遗憾了嘛对不对。</p>
<p>这一篇将主要介绍Go当中的类型系统和面向对象编程实现。</p>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅谈Angular与React]]></title>
    <link href="http://jimliu.net/2015/02/05/angular-vs-react-in-shallow/"/>
    <id>http://jimliu.net/2015/02/05/angular-vs-react-in-shallow/</id>
    <published>2015-02-04T16:23:12.000Z</published>
    <updated>2015-03-26T11:21:23.000Z</updated>
    <content type="html"><![CDATA[<p>用Angular写了一个管理系统，用React只写了几百行玩具代码。</p>
<p>因此是浅谈，真的很浅，完全可以说是对手感的评价。</p>
<a id="more"></a>
<h2 id="UI描述">UI描述</h2><h3 id="Angular">Angular</h3><p>Angular基本是做到了声明式UI，<code>ng-if</code>、<code>ng-repeat</code>这类的“流程控制”语法虽然看起来土鳖，但活儿好。至少对于UI的展现逻辑，基本上不再需要去它的controller里<code>if</code>或者<code>for</code>了。</p>
<h3 id="React">React</h3><p>React说它的JSX是声明式的UI，这不扯吗，用了就知道，这东西只是比编程生成UI容易那么一丁丁点，仅仅是一丁丁点。</p>
<p>要循环生成一个列表，还得先把它生成到一个数组里，再把数组塞进JSX，真是闹心。例如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CardList = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> button;</span><br><span class="line">    <span class="keyword">if</span> (loggedIn) &#123;</span><br><span class="line">      button = &lt;AddCardButton /&gt;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      button = &lt;LoginButton /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cards = <span class="keyword">this</span>.props.data.map(<span class="function"><span class="keyword">function</span><span class="params">(item)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Card data=&#123;item&#125; /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"card-list"</span>&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;cards&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;div className=<span class="string">"footer"</span>&gt;</span><br><span class="line">          &#123;button&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>不要怀疑哦，上面演示的条件与循环的实现基本上就是官方示例里面给的方式。恶心吗？恶心就对了。</p>
<h2 id="UI构建">UI构建</h2><h3 id="Angular-1">Angular</h3><p>Angular的UI构建基本上还是按照“模板”的思路，是基于文本的，稍微方便一点代码分离啊、build啊什么的。管理文本资源对于前端来说是很熟悉的事情。</p>
<h3 id="React-1">React</h3><p>React当中没有模板，它万物皆组件。JSX是编程语言，React的“模板”是基于DOM的，于是所有UI都是程序片段，视图与逻辑的分离的界线变得非常模糊。</p>
<p>用JSX几乎是构建React组件的唯一办法，因为不用JSX的话，手写那些<code>React.createElement</code>无疑是反人类的，而且更跟“声明式UI”没有半毛钱的关系了。</p>
<p>当然理解React的UI是程序片段这一点后，也就有办法来做视图和逻辑的拆分了——把视图当做JS模块来管理，可以部分借鉴现在各种JS模块化的思路。不过技术实现上差强人意。因为我没专注研究，就不丢人现眼了。</p>
<h2 id="数据驱动UI">数据驱动UI</h2><p>两者都实现了由model去驱动view，本世代的前端框架，包括不限于Ember、Polymer、Vue、Avalon都是这个思路，可以说以jQuery为代表的围绕DOM操作构建UI的时代已经过去了。</p>
<h3 id="Angular-2">Angular</h3><p>Angular用脏检查驱动视图更新，如果理解了<code>$digest</code>循环，就基本上了解了什么时候视图会被更新，如果要整合自己已有的组件，可以脱离<code>$digest</code>循环尽情玩耍，完事以后一个<code>$apply</code>把控制权交回去。被诟病的就是性能问题了。</p>
<h3 id="React-2">React</h3><p>React使用虚拟DOM，可谓天马行空。</p>
<p>React开发者认为“组件就是一个个状态机”（原文：React thinks of UIs as simple state machines），所以它是通过<code>setState</code>来驱动的。于是事实上你会发现还是需要手工去<code>setState</code>更新状态。当然对于控制狂来说这是好的，首先是UI的更新时机变得很明确；其次React认为这样可以让UI变得“Predictable”，可以通过编写任意<code>state</code>来精确地控制UI，提高UI的可测性。</p>
<p>但虚拟DOM和传统DOM之间几乎是不兼容的，如果要整合一些自己已有的组件，而这些组件——不管是为了实现方便还是为了性能——有魔改DOM，比如modal把元素摘到body上去方便定位；比如slide每次只保留两个元素其他一律干掉。那么会打破虚拟DOM与传统DOM之间的关联关系，React会无情罢工。</p>
<blockquote>
<p>Unable to find element. This probably means the DOM was unexpectedly mutated (e.g., by the browser), usually due to forgetting a &lt;tbody&gt; when using tables, nesting tags like &lt;form&gt;, &lt;p&gt;, or &lt;a&gt;, or using non-SVG elements in an &lt;svg&gt; parent. Try inspecting the child nodes of the element with React ID</p>
</blockquote>
<h2 id="基础设施">基础设施</h2><h3 id="Angular-3">Angular</h3><p>Angular提供了大量的基础设施，如大量的内建<code>directive</code>、依赖注入等，明确了<code>controller</code>、<code>service</code>等概念，这样就给出了一个基本稳定的应用开发的路数。不论这种大量输出价值观是否好坏，至少在使用Angular开发该怎么构建应用程序的问题分歧是比较少的。</p>
<h3 id="React-3">React</h3><p>React几乎不提供任何基础设施，我并不理解这一点是因为他们不输出价值观还是完成度不够。React的官方文档目录里面“TIPS”栏目几乎与“GUIDES”栏目一样多，让我觉得有点尴尬。相比Angular的大而全，React比较专注于以一种“万物皆组件”的方式构建一个干净的UI，而并不是构建一个完整的应用程序（那是Flux里的内容）。</p>
<h2 id="周边设施">周边设施</h2><h3 id="Angular-4">Angular</h3><p>Angular的插件很丰富，ui-router几乎是市面上最强的SPA路由组件；ng-resource把数组魔改成Promise也是有点儿意思。如上文所说，理解了<code>$digest</code>循环后要整合现有的UI组件并不难。</p>
<h3 id="React-4">React</h3><p>React的插件相对要少一些，本次React Conf上有演示的一个router组件我没体会过，不评价。如上文所说，因为虚拟DOM与传统DOM之间微妙的关系，整合现有UI组件会比较容易踩坑。</p>
<h2 id="结论">结论</h2><p>如果Angular是一个家务活干得好的小媳妇儿，那么React就是一个磨人的小妖精。</p>
<p>虽然很多人都觉得Angular主张太强，但其实除了“数据驱动UI”的观念需要稍微突破一下，两者相比之下Angular并没有那么多概念冲击，反而React要舍弃不少东西。</p>
<p>经我观察其实Facebook也只在个人主页的侧边栏使用了React，然后据说Instagram是整个用React的，因为我不玩这个就没试。</p>
<p>用React构建应用程序会存在方法论的分歧，当然既然React很专注解决UI组件的问题，那么我们可以用它配合一些之前对于View做的不好的框架，嗯你一定知道我说的就是backbone。</p>
<p>Angular受大家诟病性能的问题比较突出，移动端肯定没戏了，React据说性能很好，这个我没有去评估。</p>
<p>结论之结论：Angular是一个循序渐进的MVVM框架，之所以说循序渐进，是因为这些概念在其他语言和平台上面都已经得到过验证了，希望Angular 2.0能继续保留这些中庸而好用的哲学。React是一个狼群中的异类，JSX的存在让我觉得他们团队有JS偏执，虚拟DOM的存在让我觉得这个东西并不是Web开发，使用React开发项目也许需要做好面对“Culture Shock”的准备。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>用Angular写了一个管理系统，用React只写了几百行玩具代码。</p>
<p>因此是浅谈，真的很浅，完全可以说是对手感的评价。</p>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6 generator函数与co再一瞥]]></title>
    <link href="http://jimliu.net/2015/01/18/more-about-es6-generator-function/"/>
    <id>http://jimliu.net/2015/01/18/more-about-es6-generator-function/</id>
    <published>2015-01-18T10:31:35.000Z</published>
    <updated>2015-03-26T11:21:23.000Z</updated>
    <content type="html"><![CDATA[<p>离上文<a href="/2014/11/28/a-brief-look-at-es6-generator-function/">《ES6 generator函数与co一瞥》</a>已经过去了两个月，真是惭愧，赶紧补完。</p>
<p>本文将会介绍ES6中的<code>generator/yield</code>的异常处理，以及分析并实现一个简单的、只支持Promise的<a href="https://github.com/tj/co" target="_blank" rel="external">co</a>，嗯我们这里山寨的叫做<code>cool</code>。</p>
<a id="more"></a>
<h2 id="异常处理">异常处理</h2><p>这里我们分两种情况来看，一种是在<code>generator function</code>当中发生的异常，一种是在迭代中发生的异常。</p>
<h3 id="在generator_function中发生的异常">在generator function中发生的异常</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">boring</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'one'</span>;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'oops'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'two'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gen = boring();</span><br><span class="line"><span class="keyword">var</span> iter = gen.next();</span><br><span class="line"><span class="keyword">while</span> (!iter.done) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(iter.value, iter.done);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    iter = gen.next();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'exception happend while iterating:'</span>, ex);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码只会输出<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one <span class="keyword">false</span></span><br><span class="line"><span class="keyword">exception</span> happend <span class="keyword">while</span> iterating: oops</span><br></pre></td></tr></table></figure></p>
<p>因为在继续第二个<code>next()</code>的时候，发生了异常，这个异常导致迭代终止了。</p>
<h3 id="在迭代中发生的异常">在迭代中发生的异常</h3><p>通过<code>gen.throw()</code>可以把异常抛到<code>generator function</code>里面去，它会作为“整个<code>yield</code>表达式的异常”，然后迭代将会继续。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">boring</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'one'</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'exception caught inside:'</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'two'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gen = boring();</span><br><span class="line"><span class="keyword">var</span> iter = gen.next();</span><br><span class="line"><span class="keyword">while</span> (!iter.done) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(iter.value, iter.done);</span><br><span class="line">  <span class="keyword">if</span> (iter.value === <span class="string">'one'</span>) &#123;</span><br><span class="line">    iter = gen.throw(<span class="string">'shut up'</span>); <span class="comment">// 强行异常，无情无义无理取闹</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iter = gen.next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将会输出<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one false</span><br><span class="line">exception caught <span class="keyword">inside</span>: shut up</span><br><span class="line">two false</span><br></pre></td></tr></table></figure></p>
<p>当然，如果<code>generator function</code>内部没有捕获这个异常，最终它还是会被抛到外界来，回到上文的情况1。</p>
<h3 id="用于将异步的错误处理同步化">用于将异步的错误处理同步化</h3><p>结合上面两个特性，我们可以将<code>yield</code>表达式当中的异步操作中的错误处理进行“同步化”，我们知道异步操作最恶心的地方就是错误处理，例如thunk风格的错误处理<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(path, <span class="function"><span class="keyword">function</span><span class="params">(err, data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">    <span class="comment">// 正常</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>或者Promise风格的错误处理<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 正常</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 异常</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>很容易把程序逻辑扯得支离破碎。而同步的错误处理就容易得多，可以直接用JS的结构化异常处理<code>try/catch/finally</code>。<br>于是我们可以扩展上一篇文章当中的<code>async</code>函数（本文将改名叫<code>cool</code>），让它对于<code>yield</code>表达式中的异步操作也可以进行错误处理，并且将错误通过<code>gen.throw</code>抛回<code>generator function</code>内，从而内部就可以使用<code>try/catch</code>来处理异常了。</p>
<h2 id="动手实现一个co">动手实现一个co</h2><p>为了简化代码，我们先去掉对<code>yield</code>一个thunk的支持，只留下对于<code>Promise</code>和<code>generator</code>的支持，并且最终也把这组“同步化”之后的异步操作返回为一个Promise。</p>
<h3 id="核心">核心</h3><p>回顾一下前作当中的<code>async</code>函数，它已经做到了</p>
<ul>
<li><code>yield</code>一个thunk函数</li>
<li><code>yield</code>一个普通值</li>
<li>完成迭代</li>
</ul>
<p>这次我们先把thunk函数换成Promise的风格，然后还差的是</p>
<ul>
<li>通过<code>gen.throw()</code>将Promise的错误抛到<code>generator function</code>内</li>
<li>让<code>cool</code>返回一个Promise</li>
<li>对于<code>generator function</code>没能处理的异常，将其转化成Promise风格的错误处理<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cool</span><span class="params">(gen)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iter = gen();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onResolve</span><span class="params">(data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> it = iter.next(data); <span class="comment">// 进行一步迭代</span></span><br><span class="line">        step(it);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        reject(ex); <span class="comment">// 捕获到generator function内的异常，终止迭代</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onReject</span><span class="params">(err)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> it = iter.<span class="keyword">throw</span>(err);</span><br><span class="line">        <span class="comment">// 将yield表达式中的异步操作的错误抛进generator function，并继续迭代</span></span><br><span class="line">        step(it);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        reject(ex); <span class="comment">// generator function没有妥善处理异常，终止迭代</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span><span class="params">(it)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (it.done) &#123;</span><br><span class="line">        <span class="comment">// 迭代已完成</span></span><br><span class="line">        resolve(it.value);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> value = it.value;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 收到的是一个Promise</span></span><br><span class="line">        value.then(onResolve, onReject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 收到的是一个值</span></span><br><span class="line">        onResolve(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onResolve(); <span class="comment">// 开始迭代</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的代码和co@4.0的核心代码几乎如出一辙，当然少了很多各种异步API格式的兼容，但是实际上<code>generator/yield</code>真的就是这么简单，很难写出什么花样来。</p>
<p>现在我们的<code>cool</code>函数已经可以支持<code>try/catch</code>和<code>yield Promise</code>的用法了</p>
<h3 id="试试看">试试看</h3><p>先写一个名为<code>sleepRandom</code>的辅助函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleepRandom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ms = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">500</span>);</span><br><span class="line">    setTimeout(resolve.bind(<span class="keyword">this</span>, ms), ms); <span class="comment">// Promise的返回值就是sleep的毫秒数</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="顺序执行">顺序执行</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boringJob = cool(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="string">'yield sync value'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">var</span> ms = <span class="keyword">yield</span> sleepRandom();</span><br><span class="line">    <span class="built_in">console</span>.log(i, ms);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'success'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">boringJob.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finished:'</span>, data);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'failed:'</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> sync <span class="keyword">value</span></span><br><span class="line"><span class="number">0</span> <span class="number">47</span></span><br><span class="line"><span class="number">1</span> <span class="number">343</span></span><br><span class="line"><span class="number">2</span> <span class="number">40</span></span><br><span class="line"><span class="number">3</span> <span class="number">339</span></span><br><span class="line"><span class="number">4</span> <span class="number">423</span></span><br><span class="line">finished: success</span><br></pre></td></tr></table></figure></p>
<p>这个例子中，<code>sleepRandom</code>本来是一个异步的操作，但是被我们的“语法糖”搞成同步的了，JS也能sleep了，你满足了吧……</p>
<h4 id="未处理异常">未处理异常</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(reject.bind(<span class="keyword">this</span>, <span class="string">'breaking bad'</span>), <span class="number">200</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> weakJob = cool(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="string">'yield sync value'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">yield</span> bad()); <span class="comment">// bad()被reject后，其错误将会作为`yield bad()`语句的异常抛出</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">yield</span> sleepRandom());</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'success'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">weakJob.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finished:'</span>, data);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'failed:'</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield </span>sync value</span><br><span class="line"><span class="label">failed</span>: <span class="keyword">breaking </span><span class="keyword">bad</span></span><br></pre></td></tr></table></figure></p>
<p>因为<code>yield bad()</code>的异常没被处理，它就被抛出来了，一来造成迭代终止，二来造成了<code>weakJob</code>被<code>reject</code>。</p>
<h4 id="用try/catch/fanally处理异步任务的异常">用try/catch/fanally处理异步任务的异常</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> robustJob = cool(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="string">'yield sync value'</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> bad());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'caught exception:'</span>, ex); <span class="comment">// 异常被处理了，不会造成迭代终止</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">yield</span> sleepRandom());</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'success'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">robustJob.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finished:'</span>, data);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'failed:'</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield </span>sync value</span><br><span class="line"><span class="label">caught</span> exception: <span class="keyword">breaking </span><span class="keyword">bad</span><br><span class="line"></span><span class="number">487</span></span><br><span class="line"><span class="label">finished</span>: success</span><br></pre></td></tr></table></figure></p>
<p>这个例子中，虽然<code>bad</code>是一个异步操作，但是因为我们的<code>cool</code>函数把<code>Promise</code>的错误处理格式转换成了<code>try/catch</code>，所以可以用编写同步代码的方式来处理异常了，编程体验好多了。</p>
<h3 id="补充">补充</h3><p>然后我们再实现一个<code>yield</code>另一个<code>generator</code>的兼容，这个就很简单了。</p>
<p>首先对<code>cool</code>的传入参数进行一下重构，使其可以兼容<code>generator</code>和<code>generator function</code>两种输入<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cool</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iter = <span class="keyword">typeof</span> gen === <span class="string">'function'</span> ? gen() : gen;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onResolve</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>然后对<code>yield</code>内容是<code>generator</code>的情况也做一下兼容<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (typeof <span class="keyword">value</span>.<span class="keyword">then</span> === <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="comment">// 收到的是一个Promise</span></span><br><span class="line">  <span class="keyword">value</span>.<span class="keyword">then</span>(onResolve, onReject);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeof <span class="keyword">value</span>.next === <span class="string">'function'</span> &amp;&amp; typeof <span class="keyword">value</span>.<span class="keyword">throw</span> === <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="comment">// 收到的是一个Generator，将其用cool包装为一个Promise然后继续</span></span><br><span class="line">  cool(<span class="keyword">value</span>).<span class="keyword">then</span>(onResolve, onReject);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 收到的是一个值</span></span><br><span class="line">  onResolve(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>于是构建了一个还算凑合够用的“同步编程、异步执行”的体系<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">boring</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">var</span> ms = <span class="keyword">yield</span> sleepRandom();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'boring'</span>, ms);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'boring end'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> boringJob = cool(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> boringResult = <span class="keyword">yield</span> boring(); <span class="comment">// 一个generator function里可以yield另一个generator</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'boring result:'</span>, boringResult);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'success'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">boringJob.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finished:'</span>, data);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'failed:'</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的例子可以看做我们把来自系统或其他库的基于callback也好，Promise也好，反正是异步操作，先封装成<code>Promise</code>，然后在我们的应用程序代码里，使用<code>cool</code>，或者<code>co</code>来实现“同步代码”，当然事实上这些代码执行的时候都还是异步的，我们只是实现了一个同步的语义。</p>
<h2 id="问题">问题</h2><h3 id="并行任务">并行任务</h3><p>JS是单线程的，因此但就JS本身而言很难说真正的“并行任务”，但是runtime是多线程的，因此我们可以充分利用这一点，比如同时开多个Ajax请求，同时开多个<code>fs.readFile</code>等等。</p>
<p>这本身不是难事，难的是当遇到类似“当a, b, c三个请求都完成时，渲染界面”这种需要控制异步流程的地方，使用<code>async.js</code>这类的工具可以帮助我们做这种操作，使用<code>Promise.all</code>也可以实现这样的语义。事到如今，JS社区对于用<code>async.js</code>、<code>then.js</code>还是<code>Promise</code>，甚至是ES6的Promise还是重新实现的Promise，还讨论的喋喋不休，乐此不疲，足见异步语义对于程序员的负担是很大的。</p>
<p>在co中，<code>yield</code>一个数组的时候，它会把这个数组中的每一项都当做<code>Promise</code>，然后用<code>Promise.all</code>来让他们并发地执行。而如果<code>yield</code>的是一个Plain Object，它会遍历这个对象所有key，将其进行“Promise化”。听起来比较复杂，不过其实也就一二十行代码的事情，有兴趣的同学自己去看看co的代码就OK了。</p>
<p>这样的话在使用co的时候，如果<code>yield</code>一个数组或者一个Plain Object，它会对数组或者对象里的各项并发地执行，当它们全部都完成的时候一次性完成<code>yield</code>，依然可以用同步的语义实现并发，例如<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var results = <span class="keyword">yield</span> [<span class="variable">$.</span>ajax(url1), <span class="variable">$.</span>ajax(url2), <span class="variable">$.</span>ajax(url3)];</span><br><span class="line"><span class="regexp">//</span> 全部完成后，<span class="keyword">yield</span>才会完成，返回值是三个ajax的结果所组成的数组</span><br></pre></td></tr></table></figure></p>
<h3 id="调用栈">调用栈</h3><p>前阵子有爆料co在某些情况下会出现Maximum call stack size exceeded的情况（<a href="https://gist.github.com/zensh/797feb9ae72eac901021" target="_blank" rel="external">例子</a>），其实非常符合预期并且好理解，这是因为用同步语义写的循环<code>yield</code>代码将会被变换成函数调用，一不小心就会造成非常长的Call Stack。解决的办法也比较容易，那就是<strong>不要yield同步函数</strong>。</p>
<p>在我们这个例子里没这个问题，因为我们用的是ES6的Promise，它是严格异步的。而co支持yield一个thunk，thunk虽然是callback语义，但是没有任何担保它是异步的，也就是说thunk有“同步callback”和“异步callback”之分，这就是I神所谓<a href="http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony" target="_blank" rel="external">“Release Zalgo”</a>的问题，有兴趣可以继续探讨下。</p>
<h3 id="支持程度">支持程度</h3><p>JS最让人恶心的地方就是有了新特性你不知道敢不敢用，因为不知道<code>generator/yield</code>支持程度怎么样。</p>
<ul>
<li>在node.js &gt;= 0.11的版本中通过<code>--harmony</code>或<code>--harmony-generator</code>参数可以开启支持。</li>
<li>在io.js &gt;= 1.0中已经相当于默认开启了这个支持。</li>
<li>在Chrome较高版本中通过<code>chrome:flags</code>中的“启用实验性 JavaScript”可以开启支持。</li>
<li>通过<a href="https://github.com/facebook/regenerator" target="_blank" rel="external">regenerator</a>可以将<code>generator/yield</code>代码编译成ES5代码，用的时候需要一个大约500行源码的runtime。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>离上文<a href="/2014/11/28/a-brief-look-at-es6-generator-function/">《ES6 generator函数与co一瞥》</a>已经过去了两个月，真是惭愧，赶紧补完。</p>
<p>本文将会介绍ES6中的<code>generator/yield</code>的异常处理，以及分析并实现一个简单的、只支持Promise的<a href="https://github.com/tj/co">co</a>，嗯我们这里山寨的叫做<code>cool</code>。</p>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个伪前端的Go入门]]></title>
    <link href="http://jimliu.net/2015/01/17/beginning-go/"/>
    <id>http://jimliu.net/2015/01/17/beginning-go/</id>
    <published>2015-01-17T15:42:34.000Z</published>
    <updated>2015-03-26T11:21:23.000Z</updated>
    <content type="html"><![CDATA[<p>最近因为突发奇想对并发编程不知道哪就来了兴趣，然后想来Go是现在非常炙手可热的一门并发编程语言，而Erlang虽然有其迷人之处，但是这么纯正的函数式语言要学起来实在是曲线也有点陡。</p>
<p><img src="/uploads/2015/go.gif" alt="吉祥物"><br>这货是Go的吉祥物，强行卖萌，是个……鼹鼠吗？</p>
<p>OK不扯了，打算边学边写一点文章介绍下Go的入门，那么这一篇就是入门中的入门了，可能会显得有点无聊。</p>
<a id="more"></a>
<h2 id="Hello_World">Hello World</h2><p>安装：官网提供了常用系统的安装包，无需再自己编译，安装完了需要配一下<code>GOPATH</code>环境变量<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.<span class="type">Println</span>(<span class="string">"Hello, Go!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这段程序主要包含的内容是：</p>
<ul>
<li>可执行程序至少需要一个叫<code>main</code>的<code>package</code></li>
<li><code>main</code>包中包含一个签名为无参数无返回值的<code>main</code>函数作为入口函数</li>
</ul>
<p>运行：<code>go run hello.go</code><br>编译：<code>go build -o hello hello.go</code><br>开发工具：我使用的是SublimeText配合GoSublime插件，官方自带了gofmt程序用来格式化源代码，于是代码风格的争论可以减少了，GoSublime会在保存文件的时候自动调用gofmt。</p>
<h2 id="数据类型">数据类型</h2><h3 id="基础数据类型">基础数据类型</h3><ul>
<li>布尔：bool</li>
<li>整数：int, uint, int16, int32, int64等等</li>
<li>浮点数：float32, float64</li>
<li>复数：complex64, complex128</li>
<li>字符串：string</li>
</ul>
<p>其中字符串操作主要有<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Jim"</span> + <span class="string">"Liu"</span> <span class="comment">// 连接</span></span><br><span class="line"><span class="function"><span class="title">len</span><span class="params">(s)</span></span>        <span class="comment">// 长度</span></span><br><span class="line">s[<span class="number">1</span>]          <span class="comment">// 取字符</span></span><br></pre></td></tr></table></figure></p>
<p><code>int</code>和<code>int32</code>是两种类型，需要做类型转换的。<del>然后有的文档说<code>int</code>是平台无关的，有的文档说是平台相关的，傻傻分不清楚，</del>现在好了，新版的Go里面<code>int</code>长度是平台相关的。根据不同场景选择具体长度的类型是种好习惯，平常偷懒直接用<code>int</code>也无妨。</p>
<p>浮点数用<code>==</code>比较也是不安全的。</p>
<h3 id="复杂数据类型">复杂数据类型</h3><p>常用的复杂数据类型有</p>
<ul>
<li>指针</li>
<li>数组和slice</li>
<li>map</li>
<li>struct和interface</li>
<li>channel</li>
<li>枚举</li>
</ul>
<h4 id="数组和slice">数组和slice</h4><p>Go里面的数组是值类型，赋值、传参的时候会copy，这个和PHP比较像但是和C#、JS不大一样。如果想传引用可以通过指针，不过Go推荐在这种时候用slice。</p>
<p>Go里的数组比较像C里的数组，<code>[5]int</code>跟<code>[10]int</code>是两种不同的类型。数组是不可变长的，但可以通过slice来提高具体使用时候的灵活性。</p>
<p>slice和数组看起来很像<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="keyword">int</span>  <span class="comment">// 这货是个数组</span></span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">int</span> <span class="comment">// 这货是个slice</span></span><br></pre></td></tr></table></figure></p>
<p>slice用起来和Python里的数组有点像，可以把它理解为数组的一个view，而真正存放元素的是数组。那么slice是引用还是值呢？我把它当引用看，因为对它的下标赋值，会改到它指向的数组上面，传参、赋值的时候也是如此，表现和C#、JS里的基本一致。</p>
<p>一个数组上可以建立多个slice，用<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">arr</span><span class="attr_selector">[:]</span></span><br><span class="line"><span class="tag">arr</span><span class="attr_selector">[2:4]</span></span><br><span class="line"><span class="tag">arr</span><span class="attr_selector">[:5]</span></span><br><span class="line"><span class="tag">arr</span><span class="attr_selector">[5:]</span></span><br></pre></td></tr></table></figure></p>
<p>这样的语法可以方便地基于数组或者slice来生成slice，下界包含，上界不含。</p>
<p>如果懒得通过数组建立slice，可以直接用<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="typename">int</span>, <span class="built_in">len</span>)</span><br><span class="line">[]<span class="typename">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">// 显式初始化内容</span></span><br></pre></td></tr></table></figure></p>
<p>的方式来生成一个slice。</p>
<p>用<code>append(slice, 1, 2, 3)</code>或者<code>append(slice1, slice2...)</code>的方式向slice里添加元素。注意两点：1.<code>append</code>是返回新值的，而不是直接修改参数。2.可以任意多个元素作为参数，或一个slice加上<code>...</code>作为不定长参数。</p>
<p>slice和C++里的<code>vector&lt;T&gt;</code>类似，它具有<code>len(slice)</code>和<code>cap(slice)</code>两个操作，前者是元素个数，后者是容量，容量用满以后再加入新元素就会（被）扩容。</p>
<h4 id="map">map</h4><p>用惯了JavaScript的<code>{}</code>，不难发现现在随便写个程序对于字典的依赖有多大。Go很良心，把<code>map</code>做成内置类型了。而且比JS更好的是它的key不像JS那样仅限字符串或者数字。<strong>map也是引用类型</strong>。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kv := <span class="function"><span class="title">make</span><span class="params">(map[string]int)</span></span> <span class="comment">// 初始化一个key为string，value为int的map</span></span><br><span class="line">kv[<span class="string">"foo"</span>] = <span class="number">100</span>            <span class="comment">// 元素赋值</span></span><br><span class="line">val, ok := kv[<span class="string">"foo"</span>]       <span class="comment">// 查找</span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(kv, <span class="string">"foo"</span>)</span></span>          <span class="comment">// 删除</span></span><br></pre></td></tr></table></figure></p>
<p>查找的那个比较特殊，它利用了Go中的多返回值特性，如果查到了那么<code>ok</code>就是<code>true</code>，否则就是<code>false</code>。</p>
<p>值得一提的是，通过某些资料指出，Go的map是树查找结构，而不是hash，也就是说它的时间复杂度是<code>O(logn)</code>的，不是<code>O(1)</code>的。在数量小的时候也许性能会比较好，因为常数比hash表好，而数量大的时候访问时间会有增长。再结合hash碰撞、内存等各方面综合考虑，有优有劣，不展开讨论。</p>
<p>事实上也的确只要求key的类型实现了等与不等的操作，不需要实现hash操作。</p>
<h4 id="struct">struct</h4><p>Go没有<code>class</code>，但是有<code>struct</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">type</span> <span class="type">Klass</span> struct <span class="container">&#123;</span><br><span class="line">  <span class="type">Name</span>  <span class="title">string</span></span><br><span class="line">  <span class="type">Value</span> <span class="title">int</span></span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个语法跟C里的<code>typedef</code>很像，定义了个结构体。Go里面没有<code>private</code>，<code>public</code>这样的访问修饰符，首字母大写的字段是public的，首字母小写的就是private的，只能在这个<code>struct</code>所在的<code>package</code>内能访问到。</p>
<p>初始化一个struct的方法有多种，比较常用的有<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">k1 :</span>= Klass&#123;<span class="string">"Jim"</span>, <span class="number">999</span>&#125;  <span class="comment">// 带值初始化，按定义顺序传值</span></span><br><span class="line"><span class="string">k2 :</span>= Klass&#123;<span class="string">Name:</span> <span class="string">"liu"</span>&#125; <span class="comment">// 命名传参，其余参数会被赋值为对应类型的“零值”</span></span><br></pre></td></tr></table></figure></p>
<h4 id="枚举">枚举</h4><p>Go里没有严格意义上的枚举，相比C是一个不足，更不用比C#那种强类型枚举了。定义一个枚举大概是这么个样<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Direction <span class="typename">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  DirSouth Direction = <span class="constant">iota</span></span><br><span class="line">  DirNorth <span class="comment">// 后续的可以省略类型以及iota</span></span><br><span class="line">  DirEast</span><br><span class="line">  DirWest</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p><code>iota</code>是一个编译时常量，每出现一次就会自动<code>+1</code>，并且会在每个<code>const</code>声明的时候重置为0</p>
<p>可以看出这样的山寨枚举会缺少一些编译时检查，于是用一个type define来让它变成“强类型”的。而<code>iota</code>是<code>int</code>型的，可以和我们定义的类型做隐式转换，还算比较方便。</p>
<h2 id="变量">变量</h2><p>声明变量时需要指定类型<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> s1 <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> arr1 [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">int</span></span><br></pre></td></tr></table></figure></p>
<p>所以你看出来了，上面都是只声明，不赋初值的方式，要赋初值很简单，后面跟个赋值语句就行了。</p>
<p>当然也可以利用一下类型<del>推倒</del>推导<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> s1</span> = <span class="string">"hello"</span></span><br><span class="line">s2 := <span class="string">"world"</span></span><br></pre></td></tr></table></figure></p>
<p>上面这两种写法没声明类型，是靠类型推导来完成的，很方便，尤其是最后一种，是非常常用的写法。</p>
<h2 id="流程控制">流程控制</h2><h3 id="条件">条件</h3><h4 id="if">if</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">condition</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> another_condition &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几个要点</p>
<ul>
<li>条件语句不加括号</li>
<li>左花括号<code>{</code>不换行（<img src="/uploads/public/bye.gif" alt="">代码风格之争）</li>
<li>即使只有一句话也必须加花括号（<img src="/uploads/public/bye.gif" alt="">代码规范之争）</li>
</ul>
<p><code>if</code>的条件之前还可以放一个短的声明语句，放个临时的条件变量简直不要太方便<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="function"><span class="keyword">val</span>, <span class="title">ok</span> :</span>= kmap[<span class="string">"foo"</span>]; ok &#123;</span><br><span class="line">  fmt.<span class="type">Println</span>(<span class="function"><span class="keyword">val</span>)</span><br><span class="line"></span>&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fmt.<span class="type">Println</span>(<span class="string">"not found"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="switch">switch</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> :</span>= <span class="number">1</span></span><br><span class="line">switch <span class="function"><span class="keyword">val</span> &#123;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  fallthrough</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要点：case后面的值可以是多个；默认不fallthrough，可以通过<code>fallthrough</code>语句来显式达成。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> :</span>= <span class="number">1</span></span><br><span class="line">switch &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="function"><span class="keyword">val</span> <span class="title">==</span> 0:</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span> &lt; <span class="function"><span class="keyword">val</span> <span class="title">&amp;&amp;</span> <span class="title">val</span> <span class="title">&lt;</span> 100:</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  fallthrough</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要点：switch后面不跟变量的时候，case后面可以是完整的表达式，很多时候这种写法可以取代<code>if/else</code>。</p>
<h3 id="循环">循环</h3><p>Go里面只有<code>for</code>循环一种循环，但是它有几个变种。</p>
<p>最基础的<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> := <span class="number">0</span>; <span class="built_in">i</span> &lt; <span class="number">10</span>; <span class="built_in">i</span>++ <span class="cell">&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>当起始语句和累加语句不写时，那两个分号也可以省了，这个就相当于<code>while</code>了<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sum</span> := <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">sum</span> &lt; <span class="number">1000</span> &#123;</span><br><span class="line">  <span class="keyword">sum</span> += <span class="keyword">sum</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有“for-ever”<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>for</code>循环可以通过<code>break</code>打断，<code>continue</code>跳过。</p>
<p><code>for</code>循环可以配合<code>range</code>来更方便地遍历数组、slice、KV、channel等，例如<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">for</span> <span class="tag">k</span>, <span class="rule"><span class="attribute">v </span>:<span class="value">= range kv &#123;</span><br><span class="line">  fmt.<span class="function">Println</span>(k, <span class="string">":"</span>, v)</span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="函数">函数</h2><h3 id="基础概念">基础概念</h3><ul>
<li>函数是一等公民</li>
<li>函数是强类型的</li>
<li>函数可以有多返回值，可以使用named返回值</li>
<li>函数也有闭包</li>
</ul>
<h4 id="简单函数，A+B_Problem">简单函数，A+B Problem</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="keyword">int</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多返回值">多返回值</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func divide(a, b <span class="type">int</span>) (<span class="literal">result</span> <span class="type">int</span>, err <span class="type">string</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="string">"divided by zero"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a / b, <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果具名返回值都已经被赋值了，那么可以直接<code>return</code>就能返回多个值</p>
<h4 id="不定参数">不定参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> printEverything(message <span class="typename">string</span>, args ...<span class="typename">string</span>) &#123;</span><br><span class="line">  fmt.Println(message)</span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> args &#123;</span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printEverything(<span class="string">"hello"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br></pre></td></tr></table></figure>
<p>这里本质上<code>args</code>是一个<code>[]string</code>的slice。</p>
<h4 id="函数变量_&amp;&amp;_匿名函数">函数变量 &amp;&amp; 匿名函数</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">sayHello </span>:<span class="value">= <span class="function">func</span>(name string) &#123;</span><br><span class="line">  fmt.<span class="function">Println</span>(<span class="string">"hello"</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">sayHello</span>(<span class="string">"jim"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p><code>sayHello</code>是一个函数变量，它的值是一个匿名函数，和JS里差不多，区别就是Go里的函数变量是强类型的。</p>
<h4 id="闭包">闭包</h4><p>这个就不演示了，和JS里的闭包差不多。</p>
<h2 id="下期预告">下期预告</h2><p>这一篇介绍的东西都太基础，比较无聊，接下来的内容应该会稍微有意思点，希望不要“有生之年”。</p>
<p>下一篇应该会包含如下内容</p>
<ul>
<li>关于struct的更多：Go里的“面向对象”和interface</li>
<li>channel和goroutine简单应用</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近因为突发奇想对并发编程不知道哪就来了兴趣，然后想来Go是现在非常炙手可热的一门并发编程语言，而Erlang虽然有其迷人之处，但是这么纯正的函数式语言要学起来实在是曲线也有点陡。</p>
<p><img src="/uploads/2015/go.gif" alt="吉祥物"><br>这货是Go的吉祥物，强行卖萌，是个……鼹鼠吗？</p>
<p>OK不扯了，打算边学边写一点文章介绍下Go的入门，那么这一篇就是入门中的入门了，可能会显得有点无聊。</p>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6 generator函数与co一瞥]]></title>
    <link href="http://jimliu.net/2014/11/28/a-brief-look-at-es6-generator-function/"/>
    <id>http://jimliu.net/2014/11/28/a-brief-look-at-es6-generator-function/</id>
    <published>2014-11-28T11:23:12.000Z</published>
    <updated>2015-03-26T11:21:23.000Z</updated>
    <content type="html"><![CDATA[<p>最近开始学（其实就是玩）ES6里的<code>generator/yield</code>，以及传说中的<a href="https://github.com/tj/co" target="_blank" rel="external">co</a>。</p>
<a id="more"></a>
<p>首先，我不会Python，所以这是第一次接触<code>generator/yield</code>这种非阻塞编程方式。其次，我虽然知道也很喜欢C#中的<code>async/await</code>，虽然了解一点coroutine/goroutine，但是都没用这两种方式写过正经代码，所以应该说不会受它们影响太多。</p>
<p>话不多说先来看一看<code>generator</code>函数。</p>
<p>JS里的<code>generator</code>函数是一种特殊类型的函数，通过<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>来声明一个<code>generator</code>函数，它和普通函数不一样，虽然在<code>generator</code>函数里也可以<code>return</code>，但是实际上<code>generator</code>函数的返回值是一个<strong>迭代器</strong>，所以<code>generator</code>函数是一个<strong>生成迭代器</strong>的函数，相信这就是<code>generator function</code>名字的由来吧。<br>这里举一个最简单的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">simpleGen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hehe'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iter = simpleGen();</span><br></pre></td></tr></table></figure></p>
<p><code>iter</code>就是一个<strong>迭代器</strong>，我们可以通过next()所返回的“迭代指针”来迭代，比如：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var it = iter.next<span class="params">()</span>;</span><br><span class="line">console.<span class="built_in">log</span><span class="params">(it.value)</span>; <span class="comment">// 'hehe'</span></span><br><span class="line">console.<span class="built_in">log</span><span class="params">(it.done)</span>;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>好嘛，因为上面的<code>simpleGen</code>里面直接<code>return</code>了，所以所谓迭代其实只是看了个最终结果。<br>那么问题来了，怎么才能让它被迭代起来呢！！<br>这时候就要配合<code>yield</code>使用了，<code>yield</code>的意思就是“让步”，在它跟C#里面的<code>yield return</code>差不多。外部调用一次调用<code>next</code>，内部进行一步迭代。每一次<code>yield</code>就是所谓的一步，这时迭代器将会暂停工作，并保留所有现场。而代码执行的机会会被让给外部，直到再次<code>next</code>，迭代将会继续。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function* gen2()&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hehe'</span>;</span><br><span class="line">&#125;</span><br><span class="line">var iter = gen2();</span><br><span class="line">iter.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123; <span class="symbol">value:</span> <span class="number">1</span>, <span class="symbol">done:</span> <span class="keyword">false</span> &#125;</span><br><span class="line">iter.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123; <span class="symbol">value:</span> <span class="number">2</span>, <span class="symbol">done:</span> <span class="keyword">false</span> &#125;</span><br><span class="line">iter.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123; <span class="symbol">value:</span> <span class="string">'hehe'</span>, <span class="symbol">done:</span> <span class="keyword">true</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个迭代器的概念很像STL里的迭代器，有木有？但是，这时候你会说这特么手工<code>next</code>也能叫迭代？好的，ES6提供了<code>for of</code>语法<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="literal">it</span> <span class="keyword">of</span> gen2())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="literal">it</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码会输出1和2，但是不会输出’hehe’，我不知道是设计如此还是暂时没实现……而且资料上显示的是<code>for (let xx of xxx)</code>才对啊导演。<br>算了不管了，继续。<code>yield</code>字面意思就是“让步”，可以把执代码执行“让”给<code>yield</code>表达式来执行，而不是像写异步回调那样接着往下执行。呵呵呵呵，真是好人啊。<code>yield *</code>后接一个迭代器就可以把执行的机会让给这个迭代器，比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'1-1'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'1-2'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'2-1'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* gen1();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'2-2'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> it <span class="keyword">of</span> gen2())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果就是<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2-1</span><br><span class="line">1-1</span><br><span class="line">1-2</span><br><span class="line">2-2</span><br></pre></td></tr></table></figure></p>
<p>那么问题来了，不是说这货能用来控制流程，简化异步代码的编写吗？</p>
<blockquote>
<p>答案就是<code>next</code>可以接收一个参数，它会作为这一次迭代的<code>yield</code>表达式在<code>generator function</code>当中的返回值。</p>
<p>因为直到迭代器被再次调用<code>next</code>为止，<code>generator function</code>都是处于“让步”状态，所以这段时时间内其实可以做任何操作，<strong>不论是同步的还是异步的</strong>。</p>
<p>所以如果我们发现<code>yield</code>表达式的返回值是一个异步操作，比如<code>thunk</code>、<code>Promise</code>、<code>迭代器</code>、<code>generator function</code>，那就意味着<strong>这个操作还没有真正执行完</strong>！</p>
<p>那么问题就简单了，<strong><code>yield</code>不知道它是异步的，但是我们知道啊</strong>，甚至我们可以“万物皆异步”，我们可以让<strong>异步操作结束后再调用<code>next</code></strong>，从而实现<del>化腐朽为神奇</del>变异步为同步。</p>
</blockquote>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomDelay</span><span class="params">()</span>&#123;</span></span><br><span class="line">  var time = Math.random<span class="params">()</span> <span class="built_in">*</span> <span class="number">500</span>;</span><br><span class="line">  return <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>&#123;</span></span><br><span class="line">    setTimeout<span class="params">(callback.bind<span class="params">(this, time)</span>, time)</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genSlowly</span><span class="params">()</span>&#123;</span></span><br><span class="line">  <span class="keyword">for</span> <span class="params">(var i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span><span class="params">(i)</span>;</span><br><span class="line">    console.<span class="built_in">log</span><span class="params">(yield randomDelay<span class="params">()</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">async<span class="params">(genSlowly)</span>;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码我们希望实现打印一个数，调用一个异步操作<code>randomDelay()</code>，它的作用是随机延迟一段时间（你可以把它YY成一个ajax请求），然后通过回调函数的方式返回这个延迟毫秒数，在外层的<code>genSlowly()</code>函数能够拿到这个返回值，并且打印。<br>于是大概是这么个意思……<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span><span class="params">(gen)</span>&#123;</span></span><br><span class="line">  var iter = gen<span class="params">()</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">nextStep</span><span class="params">(it)</span>&#123;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(it.done)</span> return; <span class="comment">// 迭代已完成</span></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(typeof it.value === 'function')</span>&#123;</span><br><span class="line">      <span class="comment">// 收到的是一个thunk函数，需要等它完成的时候再继续迭代</span></span><br><span class="line">      it.value<span class="params">(function<span class="params">(ret)</span>&#123;</span><br><span class="line">        nextStep<span class="params">(iter.next<span class="params">(ret)</span>)</span>; // 把thunk的回调参数传入next，作为yield表达式的返回值</span><br><span class="line">      &#125;)</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 收到的是一个值，进行下一步迭代</span></span><br><span class="line">      nextStep<span class="params">(iter.next<span class="params">(it.value)</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nextStep<span class="params">(iter.next<span class="params">()</span>)</span>; <span class="comment">// 开始迭代</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>呵呵呵呵，成功了，虽然看起来很弱的样子。</p>
<p>通过对一个<code>generator</code>函数进行“处理”，我们可以改变它本身“迭代器生成器”的作用，用来做流程控制，这听起来真是相当蛋疼啊。不知道是谁发明的，但真是个很有创意的想法。</p>
<p>这时候<a href="https://github.com/tj/co" target="_blank" rel="external">co</a>就不难理解了，它可以将一个<code>generator</code>函数处理成一个异步操作。<strong>这样你可以在<code>generator</code>函数里面使用<code>yield</code>来实现“顺序调用，异步执行”的效果，</strong>。在co的4.0版本里它完全采用了<code>Promise</code>，它会将最终返回值作为参数传递到<code>promise</code>的<code>then</code>当中。</p>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someThingSlow</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">  setTimeout(callback, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* <span class="title">fibonacciGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = <span class="number">0</span>, p2 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> cur = p1 + p2;</span><br><span class="line">    <span class="built_in">console</span>.log(cur);</span><br><span class="line">    p1 = p2;</span><br><span class="line">    p2 = cur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> someThingSlow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 每隔一秒打印斐波那契数列，无限</span></span><br></pre></td></tr></table></figure></p>
<p>再来个例子，JS程序员梦寐以求的<code>sleep</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    setTimeout(callback, ms);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">  <span class="keyword">yield</span> sleep(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>呵呵呵呵，就是这么无聊……</p>
<p>但是！co之所以这么火并不是没有原因的，当然不是仅仅实现sleep这么无聊的事情，而是它活生生的借着<code>generator/yield</code>实现了很类似<code>async/await</code>的效果！这一点真是让我<del>三观尽毁</del>刮目相看。</p>
<p>至于具体怎么用，受篇幅限制，还是等下一篇文章再详细说明吧。嗯，我相信你已经感觉到这是又一个《有生之年》系列了（逃</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近开始学（其实就是玩）ES6里的<code>generator/yield</code>，以及传说中的<a href="https://github.com/tj/co">co</a>。</p>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于李娜退役的一点感受]]></title>
    <link href="http://jimliu.net/2014/09/19/something-about-lina-s-quit/"/>
    <id>http://jimliu.net/2014/09/19/something-about-lina-s-quit/</id>
    <published>2014-09-19T11:34:31.000Z</published>
    <updated>2015-03-26T11:21:23.000Z</updated>
    <content type="html"><![CDATA[<p>过了这么久，李娜终于还是打破沉默，正式宣布了退役。这也让我想起小时候的一点点微不足道的事情。<br><a id="more"></a></p>
<p>我小时候很爱打乒乓球，大概五年级的时候，每天下午放学我就会去和一群中学生混在一起打球，打到天黑了就回家吃饭。<br>到初一的时候，有一个很好的机会，学校将会选拔一些学生代表学校参加县里面的选拔，成功的话将会和小时候教过我打球的“偶像”哥哥们一起代表县里面去地区参加比赛。</p>
<p>经过了简单的“海选”，我记得有十来个男生、4个女生被学校选中，我们在一间空教室里摆上了球桌，买了几框球，每天放学就自己“训练”起来——加引号是因为我们没有教练指导，只有体育老师会督促我们练习和跑步。一段时间后，一些同学没有坚持下来，没再来“训练”，最后大概有6个男生、2个女生，还在坚持每天放学来打球，打到天黑——因为普通教室的灯光不足以提供打球。</p>
<p>快到了正式选拔的时候，我已经是初中组的4个男生当中表现比较好的了。入围的话，就有机会去县里面，获得更好的训练条件，以及更专业的老师的指导。哪怕最后不能代表县队出赛，也将会是一个很好的机会。</p>
<p>很可惜在选拔前一周左右的时候，我的右手食指在体育课上打篮球的时候受伤了，当时整个手指肿得很严重，筷子都拿不稳，所幸的是没有伤着骨头。我成天盼着它快点好吧快点好吧，可是看着食指上缠着的膏药，又看看作业本上用中指夹着笔写出来的蹩脚的字，我眼泪几次几欲流出来。</p>
<p>然而伤病是无情的，队内选拔赛的时候，我手上还缠着膏药，食指还是肿得像拇指那么粗。其实，说是“选拔”，但名额是弹性的，也就是说，其实我们大家都完全有机会去县里。我是队里唯一一个初一的男生，也就是最小的一个，大家都挺照顾我，甚至一位同学直接说要退出，把名额让给我。</p>
<p>现在想一想，原来我现在可笑的倔脾气，早在那时候就已经埋下种子了。我没有接受同学的好意，甚至也没有看完比赛，在中间一个休息时刻就无声的走了。</p>
<p>从那以后，我很少再打乒乓球，即使打起来也不会像当年那么认真——甚至于到后来几乎没有认真的发过几次球，而只是陪体育课上的队友不断地枯燥地练习推挡，给他指导一些动作和步法的细节，亦或者用左手陪前女友或者@licstar娱乐一下。</p>
<p>即使是我这么三脚猫的选手，伤病也是这么无情。运动员最怕的就是受伤，一旦受伤，连训练都没法保持，更别说比赛了。而且受伤期间无法训练那种感情上其实是很折磨的。也许不是我当年矫情，而是那时候那个12岁的小孩真的没法承受这么残酷的事实吧。</p>
<p>因为年纪大了或者自己不想打了而退役的运动员相比之下是比较幸运的，而因为伤病而退役的运动员则是很痛苦的，不论是身体上还是感情上，他们需要承担的东西实在太多。</p>
<p>对于困难的事情，坚持下去很难，而其中有些事，放弃也许比坚持还难。</p>
<hr>
<p>当我讲完这个故事之后，我突然觉得似乎我应该重新开始打乒乓球。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>过了这么久，李娜终于还是打破沉默，正式宣布了退役。这也让我想起小时候的一点点微不足道的事情。<br>]]>
    
    </summary>
    
      <category term="生活" scheme="http://jimliu.net/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="站着说话不腰疼" scheme="http://jimliu.net/tags/%E7%AB%99%E7%9D%80%E8%AF%B4%E8%AF%9D%E4%B8%8D%E8%85%B0%E7%96%BC/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Jim Plays <Summer>]]></title>
    <link href="http://jimliu.net/2014/07/05/summer/"/>
    <id>http://jimliu.net/2014/07/05/summer/</id>
    <published>2014-07-05T12:36:20.000Z</published>
    <updated>2015-03-26T11:21:23.000Z</updated>
    <content type="html"><![CDATA[<p>虽然不喜欢夏天，不过也是这个季节的主题曲吧，还是要欢快地弹的！<br>节奏好不稳，造成有的地方巨难听……<br>有点脑残了，用了广角镜，相机角度非常憋屈。另外视频声音好像有点小，另外优酷上好像有点音画不同步！</p>
<p><strong>视频+手机观看：</strong><a href="http://v.youku.com/v_show/id_XNzM2MTk4OTg0.html" target="_blank" rel="external">优酷</a><br><strong>MP3+高清下载：</strong><a href="http://pan.baidu.com/s/1qW2mBsK" target="_blank" rel="external">百度网盘</a></p>
<embed src="http://player.youku.com/player.php/sid/XNzM2MTk4OTg0/v.swf" allowfullscreen="true" quality="high" width="480" height="400" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash">

<p><strong>设备&amp;&amp;软件：</strong><br>键盘：Casio PX135<br>音源：The Grand 2<br>摄像：SONY NEX-6, Sigma 19/2.8<br>编辑：SONY Vegas</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然不喜欢夏天，不过也是这个季节的主题曲吧，还是要欢快地弹的！<br>节奏好不稳，造成有的地方巨难听……<br>有点脑残了，用了广角镜，相机角度非常憋屈。另外视频声音好像有点小，另外优酷上好像有点音画不同步！</p>
<p><strong>视频+手机观看：</strong>]]>
    </summary>
    
      <category term="音乐" scheme="http://jimliu.net/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个eval引发的血案]]></title>
    <link href="http://jimliu.net/2014/06/25/an-eval-cataclysm/"/>
    <id>http://jimliu.net/2014/06/25/an-eval-cataclysm/</id>
    <published>2014-06-25T03:23:12.000Z</published>
    <updated>2015-03-26T11:21:23.000Z</updated>
    <content type="html"><![CDATA[<p>昨天碰到一个线上问题，一个页面在一般的情况下加载执行，它的交互功能是正常的，但使用异步方式加载它的内容进来塞页面里，交互功能就丢掉了。</p>
<a id="more"></a>
<p>同步加载的情况就不说了，先介绍下异步的加载情况。</p>
<p>以异步方式请求同一个页面，带上特殊参数的时候，服务端会依据一些页面中埋的注释当做定界符，把页面拆成小块小块的，比如头部一块，胸部一块（←_←听起来怪怪的），<del>腿部</del>页脚一块。变成“半结构化数据”，其中每一块都是HTML片段，我们出问题的那一段就管叫<code>body</code>吧。</p>
<p>由于<code>body</code>里夹杂了一些JavaScript，又由于一些复杂的历史原因<sup>1</sup>，在异步拿到这些半结构化数据之后，需要将<code>body</code>里的<code>&lt;script&gt;</code>提取出来妥善处理之后依次执行。</p>
<p>在大多数情况下这个程序虽然看起来很trick，但是好赖运行得不错。可昨天突然遇到一个BUG，就是某个页面里的<code>body</code>在异步加载的方式下，交互功能就没了。首先可以用脚趾头确定这肯定是JS执行的问题，然后看了下这个页面的<code>body</code>内容，发现它里面有三段<code>&lt;script&gt;</code>，单步执行进去看，在异步的情况下都匹配出来了，也都执行了，但交互没生效。而将其中某一段摘出来扔控制台里再执行一遍，交互就回来了。</p>
<p>仔细观察这段问题代码，它定义了一个<strong>全局函数</strong><sup>2</sup>，定义就定义吧，这么多页面也没能一个个code review，且行且珍惜。</p>
<hr>
<p>以上就是故事背景了（比尼玛正文还长）。那为什么全局函数在这里就失效了呢？究其原因是因为<code>eval</code>。</p>
<p>在上面提到的那个加载器里面，会将匹配出来的<code>&lt;script&gt;</code>用<code>eval</code>方式执行的，<strong><code>eval</code>是局部作用域、局部作用域、作用域、域</strong>——为了凸显本文的核心问题，我将这句话的混响调长了一点点。而且这还不是问题的全部，更不可思议的是这也有<strong>浏览器兼容性问题</strong><sup>3</sup>，具体内容太复杂了，我就不搬运了，大家搜一下就行。</p>
<p>书接上回，在那个交互里，点击的时候会调用它之前定义的那个全局函数，如果正确执行的话那就刚刚好。而现在<code>eval</code>了之后，那个全局函数自然没被定义到全局上面，就挂了。神奇的是这段代码<del>很良心</del>的加了<code>try/catch</code>，于是也没看到控制台里有报错。</p>
<p>事已至此，只要倒霉加载器改用<strong>“全局eval”</strong>就能解决这个问题了（喂喂不是应该让做那个页面的人重构代码吗？），具体的方式我也不搬了，大家自己搜吧。</p>
<hr>
<h3 id="附注">附注</h3><ol>
<li>f*cking historical reasons</li>
<li>f*cking global function</li>
<li>f*cking browser compatibility problems</li>
</ol>
<h3 id="参考文献">参考文献</h3><ol>
<li><a href="http://blog.csdn.net/cuixiping/article/details/4823119" target="_blank" rel="external">让eval()全局作用域执行的方法深入研究(javascript)</a></li>
<li><a href="http://www.cnblogs.com/rubylouvre/archive/2010/04/09/1708419.html" target="_blank" rel="external">globalEval函数</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天碰到一个线上问题，一个页面在一般的情况下加载执行，它的交互功能是正常的，但使用异步方式加载它的内容进来塞页面里，交互功能就丢掉了。</p>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LRU缓存置换算法]]></title>
    <link href="http://jimliu.net/2014/05/13/lru-cache/"/>
    <id>http://jimliu.net/2014/05/13/lru-cache/</id>
    <published>2014-05-13T11:23:12.000Z</published>
    <updated>2015-03-26T11:21:23.000Z</updated>
    <content type="html"><![CDATA[<p><strong>这篇文章是科普性质的，外加推销一下中文注释……</strong></p>
<p>LRU(Least Recently Used, 近期最少使用)算法是缓存置换算法当中的经典案例——这个中文翻译听起来相当莫名其妙，所以我们还是叫LRU吧。虽然我们现在常常都用了更高阶的缓存服务，但如果要在一些语言（比如JS）当中自己实现一个简单的K-V的缓存类的时候，不放试试写一个LRU，因为它的算法思路真的相当简单，但实现起来又是非常有趣。</p>
<a id="more"></a>
<h3 id="为什么需要置换算法">为什么需要置换算法</h3><p>实现一个K-V cache的类，我们需要什么API？精简下来，我认为说到底就3个吧：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">get</span><span class="params">(key)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(key, value)</span></span></span><br><span class="line"><span class="function"><span class="title">del</span><span class="params">(key)</span></span></span><br></pre></td></tr></table></figure></p>
<p>这看起来就是一个字典而已，和LRU没什么关系。问题就在于缓存的空间是有限的，要么是硬件受限，要么是我们不想给这么多内存。所以当空间满的时候，再添加新的缓存，需要置换出去旧的。置换哪个出去就是门学问了。</p>
<p>最容易的比如FIFO，先进先出，其他还有很多，这里不详细介绍了，可以去翻翻计算机组成原理看看。</p>
<h3 id="LRU置换算法介绍">LRU置换算法介绍</h3><p>其实思路很简单，就是“把最近没用过的一个置换出去”。<br>实现上，可以描述为一个双端的列表，表头是最近用过的，而表尾是最近没用过的。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>时，如果缓存在列表里，把它摘出来放在表头上，否则直接放在表头上。</span><br><span class="line"><span class="keyword">get</span>时，把它摘出来放在表头上。</span><br><span class="line">del时，把它摘出来释放掉，如果它是表尾，那么维护一下新的表尾。</span><br><span class="line">置换时，换出表尾释放掉。</span><br></pre></td></tr></table></figure></p>
<p>很明显用一个双端队列可以比较容易地实现上述算法，主要的问题是：用双链表构造的双端队列，因为不能随机访问，在按key查找时，需要<code>O(n)</code>的时间查找。（根据局部性原理，从队头查找会更容易快速找到目标，这是一个优化点。）</p>
<h3 id="JS实现">JS实现</h3><p>isaacs大神（npm以及node.js的主要作者）的<a href="https://github.com/isaacs/node-lru-cache" target="_blank" rel="external">node-lru-cache</a>里用的是hash表加上队头和队尾两个索引来替代双链表。这样可以获得分摊<code>O(1)</code>时间的查找，构造比较巧妙。</p>
<p>我把它的源代码加了中文注释，还算比较详细吧，有兴趣的童鞋可以去看看。<a href="https://github.com/LiuJi-Jim/node-lru-cache" target="_blank" rel="external">github</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>这篇文章是科普性质的，外加推销一下中文注释……</strong></p>
<p>LRU(Least Recently Used, 近期最少使用)算法是缓存置换算法当中的经典案例——这个中文翻译听起来相当莫名其妙，所以我们还是叫LRU吧。虽然我们现在常常都用了更高阶的缓存服务，但如果要在一些语言（比如JS）当中自己实现一个简单的K-V的缓存类的时候，不放试试写一个LRU，因为它的算法思路真的相当简单，但实现起来又是非常有趣。</p>]]>
    
    </summary>
    
      <category term="编程" scheme="http://jimliu.net/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>